% !TEX root = PREN2_Dokumentation.tex
\section{Realisierung}\label{realisierung}
\subsection{Initialisierungsphase}
\subsubsection{Kick-Off Meeting}
Das Kick-Off Meeting fand am 23.02.2021 als Zoom Meeting statt. Das Sitzungsprotokoll ist im Kapitel \ref{kickOff} zu finden. \\
Es waren bei diesem Meeting alle Projektbeteiligten anwesend. In erster Linie wurde von Herr Meier das genaue Vorgehen bei der Bachelorarbeit vorgestellt. Anschliessend stellte der Auftraggeber das Projekt genauer vor und zeigte seine Erwartungen auf. Die Aufgabenstellung wurde finalisiert und von allen Projektbeteiligten akzeptiert. Zudem schlug der Betreuer vor, im Rythmus von zwei bis drei Wochen ein Meeting abzuhalten. Im Anschluss wurde ein Termin für das erste Meeting vereinbart. 
\subsubsection{Erstellen des Projektmanagementplans}
Gemäss \gls{SoDa} wurde in einem ersten Projektschritt der Projektmanagementplan \ref{Projektmanagementplan} erstellt. In diesem wurde der Rahmenplan erarbeitet. Es sind unter anderem die Meilensteine des Projekts dargestellt. Sie wurden in einem nächsten Schritt genauer spezifiziert und die Deliverables für den erfolgreichen Abschluss des Meilensteins definiert. Durch den Projektstrukturplan konnten die einzelnen Teilbereiche des Projekts aufgelistet werden.
In der folgenden Risikoanalyse wurden die Risiken und entsprechenden Gegenmassnahmen erarbeitet. \\
Als Letztes wurde die Projektunterstützung genauer spezifiziert. Dabei wurden die zu verwendenden Tools sowie die Elemente der Konfigurationseinheit festgelegt. \\
Als letzter Teil des Projektmanagements wurde die Teststrategie und die Testdrehbücher formuliert. Die Testdrehbücher werden direkt in die Testprotokolle \ref{Testprotokolle} integriert. 

\subsubsection{Problem und Vision}
Das Kapitel \ref{Problem} wurde zum Beginn der Initialisierungsphase bearbeitet. Die Hauptprobleme konnten sehr schnell gefunden werden. Die Vision des Projektes konnte mithilfe der Aussagen des Auftraggebers im Kick-Off Meeting \ref{kickOff} sehr gut beschrieben werden. 
\subsubsection{Requirement Engineering}
Beim Requirements Engineering diente die IEEE Spezifikation 29148-2018 als Grundlage [\cite{ieeeSrs}]. Um die Requirements zu finden, wurde in eine Analyse der Aufgabenstellung durchgeführt. Ergänzt wurden diese durch Befragungen des Auftraggebers. Durch die so erlangten Informationen konnten die Anforderungen formuliert werden. In einem letzten Schritt wurden diese mit dem Auftraggeber besprochen und überarbeitet. Die Requirements Specification ist im Kapitel \ref{RSR} zu finden. 
\subsubsection{Stand der Technik}
In diesem Kapitel wurde eine Analyse der bestehenden, vergleichbaren Lösungen durchgeführt. Es wurde das Angebot der Post und von Valflora genauer betrachtet. Die bekannte \gls{PWA} von Starbucks wurde als Referenz-\gls{PWA} genutzt. 
\newpage
\subsubsection{Meilenstein Abschluss Initialisierungsphase}
\paragraph{Meilensteinbericht}
\subparagraph{Termin Meilenstein 2}
Der Meilenstein 2 ist am 07.03.2021 abgeschlossen und somit pünktlich fertiggestellt worden.
\subparagraph{Beschreibung Meilenstein 2}
Die Beschreibung des Meilensteins ist im Abschnitt \ref{Meilensteine} ersichtlich. 
\subparagraph{Meilensteinziele/Vorgaben}
Das übergeordnete Ziel dieses Meilensteins ist die Fertigstellung der Initialisierungsphase.
Hierzu war die Auslieferung der nachfolgenden Artefakte notwendig:
\begin{itemize}
	\item Projektmanagementplan
	\item Systemspezifikation
	\item Anforderungsliste
\end{itemize}
Zusätzlich wurden bereits die Kapitel \ref{Problem} und \ref{StandDerTechnik} fertiggestellt. 
\subparagraph{Meilensteinzielerreichung}
Es konnten alle geforderten Artefakte geliefert werden. Die Artefakte wurden mit der Betreuungsperson im Meeting \ref{Betreuermeeting1} besprochen und konnten abgenommen werden. 
Der Meilenstein wurde erfolgreich erreicht. 
\subparagraph{Fazit}
Es wurden alle Artefakte erarbeitet. Der Meilenstein wurde somit erreicht und es kann weiter nach Plan gearbeitet werden.

\newpage
\subsection{Konzeptionsphase}
\subsubsection{Sprint 1}\label{Sprint1}
\begin{table}[H]
	\begin{tabularx}{\textwidth}{|l|X|}
		\hline
		User Story & Number \\
		\hline
		Das System ist auf eine physische Pick-Up Station abgestimmt. & F.2\\
		\hline
	\end{tabularx} 
\caption[User Stories Sprint 1]{User Stories Sprint 1, Quelle: Autor}
\end{table}\label{userStoriesSprint1}

\paragraph{Spezifikation der Schnittstelle zur Abholung}\label{SpezifikationSchnittstelleAbholung}
Um eine Abholung der Produkte durchführen zu können, braucht es eine Kommunikation zwischen  \gls{PWA} und Pick-Up Station. Um diese Schnittstelle genauer spezifizieren zu können, war es in einem ersten Schritt nötig, eine entsprechende Übertragungstechnologie festzulegen. Bei der Auswahl war dabei die Kompatibilität mit verschiedenen Geräten und Browsern ausschlaggebend. 
\subparagraph{NFC}
Als eine erste Idee wurde \ac{NFC} analysiert. \ac{NFC} eignet sich dabei ideal für die Übertragung von geringen Datenmenge. Dabei funktioniert es bis zu einer Distanz von 10cm. Die Umsetzung wäre sehr einfach mittels einem Raspberry Pi umsetzbar. Dabei könnte die gesamte Übertragung von der Informatik übernommen werden, eine weitere Schnittstelle zwischen Elektrotechnik und Informatik könnte vermieden werden.  \\Die Technologie ist sehr robust. Ein Überkleben oder Zerkratzen des Lesers hat keinen Einfluss auf dessen Funktionalität  [\cite{nfc}]. Beliebte Bezahlmethoden wie Apple Pay oder vergleichbare nutzen \ac{NFC} für die Übertragung zwischen Terminal und Smartphone. 
Der Abholvorgang wäre sehr einfach und schnell, da nur ein kurzer Kontakt mit dem Smartphone bereits ausreicht. \\\\

Apple schränkt den Zugriff von Webpages auf Standort- und Hardwaredienste unter iOS-Geräten sehr stark ein. Offiziell begründet wurde das durch die Einschränkung von footprinting und dem damit verbundenen Nutzertracking. Für das Projekt ausschlaggebend ist vor allem das Entfernen des NFC- und Bluetooth-Supports. Somit ist es auch \gls{PWA}'s nicht mehr möglich, unter iOS auf die genannten Funktionen zuzugreifen [\cite{webKitTracking}].\\
Die Web-NFC-API wird zusätzlich bislang nur von Google Chrome unterstützt. Das würde die Nutzbarkeit der Applikation sehr stark einschränken [\cite{kompWebNFC}]. 
Aus diesem Grund eignet sich \ac{NFC} nicht für die Verwendung in diesem Projekt. 
\subparagraph{QR-Code}\label{qrcode}
Die Restriktionen von Apple schränken die geeigneten Technologien sehr stark ein. Es bleibt nur noch der Zugriff auf die Kamera, um mit der Pick-Up Station zu kommunizieren. Ursprünglich war das vom Auftraggeber nicht gewünscht. Das Verwenden einer anderen Technologie würde aber zu erheblichen Einschränkungen führen, sodass die \gls{PWA} mit vielen Geräten unbrauchbar wäre. \\
Daher musste ein Konzept entwickelt werden, um die Warenausgabe mittels QR-Code auszulösen. Es sind zwei Ansätze möglich: 
\begin{itemize}
	\item Fixer QR-Code auf Pick-Up Station, wird von \gls{PWA} eingelesen. 
	\item Variabler QR-Code in \gls{PWA}, wird von Pick-Up Station eingelesen. 
\end{itemize}
Aus Hardware technischer Sicht ist die Umsetzung der ersten Lösung bedeutend einfacher, bietet aber auch erhöhtes Fehlerpotential. Ein Überkleben des QR-Codes auf der Station würde die gesamte Station unbrauchbar machen. Eine Abholung der Bestellungen wäre nicht mehr möglich. \\
Die zweite Variante ist Hardware technisch anspruchsvoller. Auf der Pick-Up Station muss ein optischer Leser verbaut werden. Mit diesem kann der QR-Code aus der \gls{PWA} eingelesen und die Bestellung ausgegeben werden. \\

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/QR-CodeOnMachine.jpg}
	\caption[Beispielanwendung QR-Code auf Gerät]{Beispielanwendung QR-Code auf Gerät,\\ Quelle: \cite{imageQRCodeTwint}}
	\label{img: Beispielanwendung QR-Code auf Geraet}
\end{figure}
Eine Grafik zum zweiten Lösungsansatz ist im Kapitel \ref{avecBox} zu finden. 
Die genaue Wahl wird im Meeting mit dem Auftraggeber besprochen und abgesegnet. 

\paragraph{Sprintreview Sprint 1}
Im Sprint 1 wurde eine genauere Analyse der Schnittstelle zur Produktabholung durchgeführt. Es müssen im Meeting von dieser Woche die gefundenen Lösungen mit dem Auftraggeber besprochen werden. Die \gls{User Story} kann erst zu Beginn des nächsten Sprints abgeschlossen werden. 

\paragraph{Meilensteinbericht}
\subparagraph{Termin Meilenstein 3}
Der Meilenstein 3 ist am 18.03.2021 abgeschlossen und somit mit drei Tagen Verspätung fertiggestellt worden. 
\subparagraph{Beschreibung Meilenstein 2}
Die Beschreibung des Meilensteins ist im Abschnitt \ref{Meilensteine} ersichtlich. 
\subparagraph{Meilensteinziele/Vorgaben}
Das übergeordnete Ziel dieses Meilensteins ist die Fertigstellung der Initialisierungsphase.
Hierzu war die Auslieferung der nachfolgenden Artefakte notwendig:
\begin{itemize}
	\item Projektmanagementplan
	\item Systemspezifikation
	\item Anforderungsliste
\end{itemize}
Zusätzlich wurden bereits die Kapitel \ref{Problem} und \ref{StandDerTechnik} fertiggestellt. 
\subparagraph{Meilensteinzielerreichung}
Es konnten alle geforderten Artefakte geliefert werden. Die Artefakte wurden bereits mit der Betreuungsperson im Meeting \ref{Beteuermeeting1} besprochen und konnten abgenommen werden. 
Der Meilenstein wurde erfolgreich erreicht. 
\subparagraph{Fazit}
Es wurden alle Artefakte erarbeitet. Der Meilenstein wurde erreicht und es kann weiter nach Plan gearbeitet werden.

\subsubsection{Sprint 2}\label{sprint2}
\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System ist auf eine physische Pick-Up Station abgestimmt. & F.2\\
		\hline
		Das System bietet dem Kunden die Möglichkeit, verschiedene Produkte zu bestellen. & F.6\\
		\hline
		Das System muss über eine CI/CD Pipeline verfügen. & L.6 \\
		\hline
		Das System muss via HTTPS kommunizieren. & L.3 \\
		\hline
	\end{tabularx} 
	\caption[User Stories Sprint 2]{User Stories Sprint 2, Quelle: Autor}
\end{table}\label{userStoriesSprint2}

\paragraph{CI/CD Pipeline}
Nach Absprache mit dem Auftraggeber im Meeting wurde entschieden, dass der Prototyp im \gls{EnterpriseLab} laufen soll, woraufhin wurde eine Maschine beantragt wurde. Es handelt sich um ein Ubuntu 16.07 LTS. Die Applikationen sollen als verschiedene Docker Container betrieben werden. \\
Zuerst wurde geplant, die Pipeline wie im offiziellen Tutorial des \gls{EnterpriseLab} zu erstellen. Auf Anfrage wurde jedoch ein anderes Vorgehen empfohlen. Nachfolgend wird die Antwort zitiert. 

"Wenn es dein Ziel ist eine Spring Boot Applikation zu builden und dann auf der VM zu deployen dann würde den Container auf den Shared Runner unserer GitLab Instanz builden lassen und in die Container Registry deines Projekts pushen. Für die Deploy Stage der CI/CD Pipeline kannst du deine VM als privaten GitLab Runner registrieren und so ohne SSH login den Container von der Registry pullen und laufen lassen. Die SSL Termination mit Lets Encrypt würde ich mit einem separaten nginx Container lösen der reverse proxy spielt. Dieser kann dann einfach laufen und muss für Änderungen an der Spring Boot Applikation auch nie modifiziert werden. Der Vorteil im Vergleich zur Docker Übung ist, dass hier alle Hosts von der GitLab CI/CD Pipeline kontrolliert werden. In der Übung ist der docker-cloud-exercise Host abgekapselt und pullt mit Watchtower einfach blind das neuste Image von einer Registry. Dieser Aufbau macht IMO mehr Sinn wenn man einfach Container Images von dritten konsumiert, aber ist weniger elegant wenn man selbst Kontrolle über die Source und CI/CD Pipelines hat." [\cite{emailEnterpriselab:private}]

In diesem Auszug aus der Email vom \gls{EnterpriseLab}-Mitarbeiter Cyrill von Uslar sind sehr viele Informationen enthalten. Es war ein mehrmaliges Durchlesen nötig, um sich darunter etwas vorstellen zu können. Die Pipelineerstellung wurde in die folgenden Punkte aufgeteilt und umgesetzt.
\begin{itemize}
	\item Builden auf dem Shared Runner 
	\item Pushen in die Container Registry des Projekts
	\item VM als privaten Runner registrieren und deployen
	\item nginx-Server als reverse Proxy für SSL Termination
\end{itemize}
\newpage
\subparagraph{Builden auf dem Shared Runner}
In diesem Projekt wird die Pipeline für zwei Projekte aufgesetzt. In einem ersten Schritt wurde das nur für die Spring Applikation durchgeführt. 
Das Vorgehen unterscheidet sich nur im Buildprozess. 
Um die Spring Applikation zu erstellen, wurde das Dockerfile identisch zum Spring Boot Docker-Tutorial aufgebaut [\cite{springBootDocker}].

\begin{verbatim}
FROM maven:3.6.3-jdk-11-slim
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
\end{verbatim}
Java 11 wurde bewusst gewählt. Zu diesem Zeitpunkt war Java 11 die aktuellste Version, welche eine slim-Edition des Images anbot. Das wirkt sich erheblich auf die Imagegrösse aus, weshalb dieser Kompromiss eingegangen wurde. 
Zum Erstellen des gitlab-ci.yml-Files wurde eine Anleitung von \gls{GitLab} genutzt. Sie war jedoch nicht mehr aktuell. Zusätzlich wird das Deployment auf ein Kubernetes Cluster durchgeführt und musste entsprechend angepasst werden. Es konnte nur der Build-Teil übernommen werden. [\cite{springBootCI}]\\
\gls{GitLab} stellt zum Erstellen von Docker-Images bereits mehrere Shared-Runner zur Verfügung. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/gitLabRunner.png}
	\caption[Verfügbare Shared-Runner von GitLab]{Verfügbare Shared-Runner von GitLab, Quelle: Autor}
	\label{img: runnerGitlab}
\end{figure}
Der jeweilige Runner wird mittels eines \gls{fairUsageAlgorithmus} zugewiesen. Zudem achtet der Runner auf die verwendeten Tags. In diesem expliziten Beispiel sind mehrere Runner mit dem Docker-Tag versehen. Daher kann nicht sicher gesagt werden, welcher Runner den Docker Build durchführt. 
\newpage
\subparagraph{Pushen in die Registry des Projekt}
Um das erstellte Image in die Registry des Projekts zu pushen, werden von GitLab bereits die einzelnen Befehle vorgegeben. Sie können in die Package-Stage integriert werden. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/gitLabRegistry.png}
	\caption[CLI Commands GitLab Container Registry]{CLI Commands GitLab Container Registry, Quelle: Autor}
\label{img: containerRegistryGitlab}
\end{figure}

Das entsprechende Image wird in die interne Container Registry des \gls{GitLab} Projekts gepushed. So kann auf das Verwenden eines Drittdienstes wie \gls{DockerHub} verzichtet werden. 
Beim Erstellen werden immer zwei Images in die Registry geschrieben. Als Tag wurde bei einem Image latest genutzt, beim Anderen der Hash des Commits. Beim Deployment wird das Image mit dem aktuellen Commit-Hash verwendet. Dieser Mechanismus dient dazu, dass alle Versionen immer vorhanden sind. Latest zeigt immer auf die aktuelle Version. 

\subparagraph{VM als privaten Runner registrieren und deployen}
Um das Deployment ohne Watchtower durchführen zu können, wurde auf die virtuelle Maschine als Docker-Runner hinzugefügt. Es handelt sich um einen specific Runner. 
\gls{GitLab} Runner kann einfach mittels Paketmanager auf Ubuntu installiert werden. Für die Konfiguration musste der Token sowie die URL von \gls{GitLab} dem Runner hinzugefügt werden. Der Runner ist im gleichnamigen Bereich des Projekts zu finden. Die Option \glqq Lock to current project\grqq{} wurde enfernt, sodass dieser Runner auch für das Angular Projekt genutzt werden kann. 
Um ein SSH-Login zu vermeiden, wurde der Executor als Shell-Executor definiert. Bei einem SSH-Executor wäre vorgängig die Verbindung via SSH nötig gewesen. Dieses Vorgehen wird nur empfohlen, wenn die Kontrolle über das Zielsystem besteht. 
Die entsprechenden Befehle konnten in das gitlab-ci.yml integriert werden. Es bestand zunächst das Problem, dass die Berechtigung fehlte. Erst nach dem Login mittels GitLab CI-Token konnte der Container erfolgreich heruntergeladen und gestartet werden. 

\subparagraph{Build und Deployment des Frontends}
Um mit dem nächsten Schritt weiterzufahren, musste zuerst das Deployment des Angular Projekts konfiguriert werden. Hierbei liegt der Hauptunterschied in dem Build-Prozess. Es ist  wichtig, die beim Build entstehenden Artefakte in GitLab zu speichern. Nur so kann auf ein erneutes Builden beim Erstellen des Docker Containers verzichtet werden. Die Node-Module werden im Cache gespeichert. Das weitere Vorgehen ist identisch. 

\subparagraph{nginx als Reverse Proxy}\label{reverseProxy}
Um den nginx-Server gegen Zugriffe von Extern zu schützen, wurde auf einen Reverse Proxy gesetzt. Der Reverse Proxy stellt die einzige Verbindung ins öffentliche Netz dar. Er übernimmt die Zertifikatsverwaltung des Frontends. Alternativ wäre ein Caching möglich, auf die Umsetzung wurde für diesen Anwendungsfall verzichtet. [\cite{reverseProxy}] \\
Die Umsetzung wurde analog zum \href{https://sitegeist.de/blog/typo3-blog/docker-compose-setup-mit-nginx-reverse-proxy.html}{Tutorial} von Alexander Bohndorf durchgeführt [\cite{confReverseProxy}]. Es wurde der \gls{nginx}-Proxy von jwilder sowie der kompatible letsencrypt companion verwendet. Die Umsetzung wurde mittels docker-compose Files durchgeführt. 

\paragraph{Abschliessende Bemerkungen}
Das Erstellen der CI/CD Pipelines des Projekts verlief problemlos. Durch die Grundlage des \gls{EnterpriseLab}s und der sehr guten Dokumentation von \gls{GitLab} konnte das sehr schnell umgesetzt werden. Durch das Hinzufügen des Reverse Proxies konnte die Sicherheit des Systems massiv erhöht werden. Zusätzlich wurde so auch gleich die Auslieferung via HTTPS hinzugefügt sowie für ein durchgehend gültiges Zertifikat gesorgt. \\
Es wurde auf zusätzliche Test oder Codeverification-Stages verzichtet. 
Die fertigen Konfigurationen sind im \gls{GitLab} Projekt enthalten und können eingesehen werden. 

\paragraph{Bestellen von Produkten}\label{order}
Um eine Bestellung durchführen zu können, wurde im ersten Schritt das Article Object definiert. Basierend darauf wurde das passende \ac{DTO} definiert. Um das Mapping zwischen \ac{DTO}'s und Objekt zu vereinfachen, wurde der Object Mapper modelmapper genutzt. 
Es direkt mit \ac{HATEOAS} gearbeitet. Der Controller stellt die gewohnten \ac{CRUD}-Operationen zur Verfügung. 

\paragraph{Abstimmung auf physische Pick Up Station}\label{abstimmungPickUp}
Im Meeting von dieser Woche wurden dem Auftraggeber die beiden in Kapitel \ref{qrcode} erarbeiteten Lösungen vorgestellt. Der Entscheid fiel zugunsten der ersten Alternative. \\
Die Schnittstellen zwischen Elektrotechnik und Informatik sind essentiell für die Funktionalität des Endprodukts. Aus diesem Grund wurde in diesem Sprint ein Meeting zwischen den Projektbeteiligten einberufen. Besonders das Senden der Ausgabeanforderung führte dabei zu Problemen. Hierbei soll auf einen Busy-Waiting Ansatz verzichtet werden. Jedoch soll die Lösung auch sehr energiesparend und effizient umsetzbar sein. Da beide Projektmitarbeiter keine Erfahrung im \ac{IoT}-Umfeld besitzen, wurde ein Meeting mit dem Betreuer Michael Handschuh einberufen. 

\paragraph{Sprintreview Sprint 2}
In Sprint 2 konnten nicht alle User Stories vollständig erfüllt werden. Es werden zwei von drei User Stories im nächsten Sprint weiter bearbeitet. Die Umsetzung der CI/CD Pipeline ist hingegen abgeschlossen. Das war auch die Hauptarbeit in diesem Sprint. Für die Spezifizierung der Schnittstelle wird beim Meeting mit dem Betreuer eine geeignete Lösung erarbeitet. Beim Bestellprozess ist bereits die Abfrage von Produkten an der API möglich. In einem nächsten Schritt wird das passende Frontend entworfen und umgesetzt. 
\newpage
\subsubsection{Sprint 3}
\paragraph{User Stories}
In diesem Sprint wurden keine neue \gls{User Story} zum Sprint Backlog hinzugefügt. Es wird weiterhin an den beiden verbleibenden User Stories gearbeitet. 

\paragraph{Abstimmung auf eine physische Pick Up Station}
Bei der Abstimmung auf die physische Pick Up Station musste das geplante Vorgehen mit dem Projektbetreuer besprochen werden. Im Meeting \ref{Beteuermeeting2} wurde eine geeignete Lösung gesucht. Es standen zwei Alternativen zur Verfügung. 
\subparagraph{WebHooks}
\gls{WebHooks} erfüllt alle Anforderungen, welche zur Kommunikation zwischen API und Pick-Up Station benötigt werden. \\Allerdings ist noch keine Erfahrung mit \gls{WebHooks} vorhanden. Jedoch kann zur Erstellung auch Node.js mit Express verwendet werden. Dieses ist bekannt und wurde auch schon in anderen Projekten genutzt.\\\\
Im späteren Projektverlauf wurde immer deutlicher, dass das Erstellen eines eigenen WebHooks-Endpoints sehr schlecht dokumentiert ist. In den meisten Beispielen wird die Anbindung an einen bereits bestehenden Endpoint umgesetzt. Verfügbare Libraries lieferten nicht den gewünschten Effekt. Es wurde eine eigene Implementation umgesetzt, welche in Kapitel \ref{nodeStation} beschrieben wird. 

\paragraph{Produktbestellung}
In diesem Sprint wurde an der Produktbestellung gearbeitet. Als Erstes wurde das Darstellen von Produkten ins Auge gefasst. Auch wurde die Grundstruktur der Angular Applikation erstellt. 
Es wurde strikt nach dem Mobile First Prinzip gearbeitet. Durch Schemantic konnten das responsive Menü sowie die Anzeige für Produkte sehr schnell erstellt werden. Im Anschluss wurde das Menü mit den gewünschten Inhalten gefüllt. \\

Bei den Produkten wurde das Card Element von Angular Material genutzt. Es wurde in ein Grid Layout verpackt. \\Damit die Seite auf allen Geräten optimal aussieht, wird das Layout basierend auf der Displaygrösse angepasst. Um das mit TypeScript umzusetzen, wurde ein Breakpoint Observer eingesetzt. Dank diesem wird die Anzahl Spalten und die Spaltenhöhe abhängig von der Geräteauflösung festgelegt. Sie wird beim Laden der Seite definiert. Es ist hier kein Listener Mechanismus nötig, da sich die Auflösung nicht während der Laufzeit ändert.\\ Um die Anzahl Spalten bei einem Wechsel in den Landscape Modus anzupassen, wurde ein neuer Observer eingesetzt. Dieser legt die entsprechende Anzahl fest. 
\begin{figure}[H]
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/rowsLand.PNG}
		\caption[Observer, Wechsel Landscape/Portrait Tablet]{Observer, Wechsel Landscape/Portrait Tablet, Quelle: Autor}
		\label{img: Landscape observer}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.6]{images/rowsRes.PNG}
		\caption[Spaltenanzahl- und Höhe abhängig von Auflösung]{Spaltenanzahl- und Höhe abhängig von Auflösung, Quelle: Autor}
		\label{img: Resolution Observer}
	\end{subfigure}
\end{figure} 
\newpage
\subparagraph{Anzeige der Produkte}
Die Abfrage der Produkte war bereits in einem vorderen Sprint \ref{order} im Backend erstellt. Die Produkte wurden analog zur Java Klasse als TypeScript Klasse definiert. Die Links via \ac{HATEOAS} wurden als eigenes Property definiert. 

Per Angular-http Client wurde ein GET-Request an die entsprechende URL gesendet. Das resultierende Observable wurde abonniert und mittels Angular Direktive als Card Element dargestellt. 

\begin{figure}[H]
	\begin{subfigure}[b]{0.45\textwidth}
		\includegraphics[scale=0.4]{images/productsPhone.PNG}
		\caption[Produktanzeige auf Pixel Phone]{Produktanzeige auf Pixel Phone, \\Quelle: Autor}
		\label{img: Prodcuts pixel}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\includegraphics[scale=0.3]{images/productsTablet.PNG}
		\caption[Produktanzeige auf iPad]{Produktanzeige auf iPad, \\Quelle: Autor}
		\label{img: Products iPad}
	\end{subfigure}
\end{figure} 

\paragraph{Sprintreview Sprint 3}
Die \gls{User Story} von dieser Woche konnten erneut nicht abgeschlossen werden. Aus diesem Grund wurden die Requirements aufgeteilt. Die neuen Requirements sind im Kapitel \ref{RSR} zu finden. 
\newpage
\subsubsection{Sprint 4}
\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System bietet die Möglichkeit, verschiedene Produkte anzuzeigen& F.5\\
		\hline
		Das System bietet die Möglichkeit, verschiedene Produkte dem Warenkorb hinzuzufügen& F.6\\
		\hline
	\end{tabularx} 
	\caption[User Stories Sprint 4]{User Stories Sprint 4, Quelle: Autor}
\end{table}\label{userStoriesSprint4}

\subparagraph{Produkte anzeigen}
Vom Auftraggeber wurden die Produkte in einer Excel Liste abgegeben. Es war auch ein Packshot vorhanden, wobei sehr schnell klar wurde, dass die Auflösung nicht ausreichend ist. Auf Nachfrage wurden hochauflösende Bilder zur Verfügung gestellt. Die Auflösung bei diesen war jedoch zu hoch. Das Laden der Seite verzögerte sich merklich. Daher mussten die Bilder komprimiert und in der Auflösung optimiert werden. Zur Komprimierung wurde das Online Tool von \href{https://compresspng.com/}{Compress PNG} genutzt. Die Auflösung wurde mit dem Preview Programm von MacOS angepasst. Dadurch konnte die Grösse eines Bildes von ca. 2MB auf 100KB heruntergebrochen werden. Die Bilder sehen für den Betrachter immer noch scharf aus. Zudem konnten die Bilder so alle auf dasselbe Format gebracht werden. \\
Um die Produkte hinzuzufügen, wurde Postman genutzt. Die einzelnen Produkte-JSONs wurden einmal erstellt und können bequem via Runner hinzugefügt werden. 
Bei einem Klick auf ein Produkt soll die Detail View angezeigt werden. Das war mittels Router Link sehr leicht umzusetzen. Mittels des Product-Services wird das ausgewählte Produkt gesetzt und angezeigt. Das Design dieser Komponente wird auf später verschoben, da die Warenkorbfunktionalität höher priorisiert ist. 

\subparagraph{Produkte dem Warenkorb hinzufügen}
Die Realisierung des Warenkorbs gestaltete sich als einfach. Angular liefert hierzu ein Tutorial. Es wurde erweitert, sodass CartItems gespeichert werden. Zusätzlich werden sie im \gls{LocalStorage} des Browser gespeichert, sodass der Warenkorb auch nach einem Reload noch vorhanden ist [\cite{cartAngular}].

Der Warenkorb wird als Angular Material List dargestellt. Die Artikelanzahl kann mittels Buttons angepasst werden. Ein Löschen wird durch einen zusätzlichen Button ermöglicht. Das Gesamttotal wird nach jeder Änderung aktualisiert. 

\begin{figure}[H]
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/cartEmpty.PNG}
		\caption[Leerer Warenkorb]{Leerer Warenkorb, Quelle: Autor}
		\label{img: cartEmpty}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/cartFull.PNG}
		\caption[Warenkorb mit Produkten]{Warenkorb mit Produkten, Quelle: Autor}
		\label{img: cartFull}
	\end{subfigure}
\end{figure} 
\newpage
\subparagraph{HTTPS bei Backend}\label{httpsBackend}
Moderne Browser erlauben das Laden von sogenanntem \gls{mixedContent} per Default nicht. Um dieses Problem zu beheben, muss das Spring Boot Backend auch via HTTPS zugreifbar sein. Mit dem Tool Certbot kann ein gültiges Zertifikat erstellt werden. Es muss im \gls{Propertie-File} des Spring Projekts angegeben werden. Das Tutorial verwendete dabei eine deprecated Version von Certbot. Dank einem Hinweis von Ubuntu wurde auf die neue Version gewechselt [\cite{springSSL}]. 

\begin{verbatim}
	certbot certonly --webroot  -d bdaf21-owerlen.enterpriselab.ch 
	--staple-ocsp -m oliverwerlen@bluewin.ch --agree-tos
\end{verbatim}

Es wird empfohlen, in Spring mit PKCS12 Files zu arbeiten. Daher wurde das erstellte PEM File konvertiert. \\\\
Certbot führt die Zertifikatserneuerung von selbst aus. 
\begin{verbatim}
	openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem -out 
	keystore.p12 -name jtipickupbackend -CAfile chain.pem -caname root
\end{verbatim}

\subparagraph{Sprintreview Sprint 4}
Im Sprint 4 konnte die Warenkorbfunktionalität abgeschlossen werden. Zudem läuft die Applikation nun auch im produktiven Umfeld.
Um die Bestellung abschliessen zu können, muss im nächsten Schritt die Authentifizierung implementiert werden.  

\subsubsection{Sprint 5}
\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System bietet dem Anwender die Möglichkeit, sich zu registrieren und anschliessend einzuloggen. & F.3\\
		\hline
		Das System muss durch einen modernen und sicheren Authentifizierungsmechanismus geschützt sein. & L. 4\\
		\hline
	\end{tabularx} 
	\caption[User Stories Sprint 5]{User Stories Sprint 5, Quelle: Autor}
\end{table}\label{userStoriesSprint5}
 In vorherigen Sprints konnten die User Stories selten fertiggestellt werden. Aus diesem Grund wurde hier nur eine kleine Story hinzugenommen.
 
\paragraph{Authentifizierung}
\subparagraph{Backend}
 In einem vorherigen Projekt wurde bereits eine Authentifizierung in Spring Boot umgesetzt. Das dort verwendete Tutorial funktionierte tadellos. Aus diesem Grund wurde entschieden, bei diesem Projekt identisch vorzugehen. Nachfolgendes Sequenzdiagramm zeigt auf, wie die einzelnen Teile miteinander kommunizieren. Es wurde auf eine Token Based Authentifizierung realisiert. Umgesetzt wurde sie mittels Spring Security. Der Token muss bei jedem Request mitgesendet werden [\cite{authAPISpring}].  
  
\begin{figure}[H]
  	\centering
  	\includegraphics[scale=0.6]{images/Authentication.PNG}
  	\caption[Authentication im Backend]{Authentication im Backend, Quelle: Autor}
  	\label{img: AuthenticationBackend}
\end{figure} 

Die Auflösung eines Tokens mittels jwt.io ist im Anhang \ref{tokenaufloesung} zu finden. 
Es wurden Rollen definiert, um die API feingranular sichern zu können. Die Rollen lauten dabei: 

\begin{itemize}
	\item User
	\item Admin
	\item Maintenance
\end{itemize}

\subparagraph{Frontend}
Um einen entsprechenden Nutzer zu erstellen \ac{bzw} die Eingabe von Logininformationen zu ermöglichen, mussten die entsprechenden Formulare erstellt werden. Sie wurde mittels Reactive Forms umgesetzt. Durch die damit verbundenen Validators wird clientseitig auf die Komplexität des Passworts, das Übereinstimmen der Beiden sowie die Korrektheit der Email-Adresse getestet. 

\begin{figure}[H]
 	\begin{subfigure}[b]{0.4\textwidth}
 		\includegraphics[scale=0.4]{images/loginForm.PNG}
 		\caption[Login Formular]{Login Formular, Quelle: Autor}
 		\label{img: loginForm}
 	\end{subfigure}
 	\hfill
 	\begin{subfigure}[b]{0.4\textwidth}
 		\includegraphics[scale=0.3]{images/registerForm.PNG}
 		\caption[Registrierungsformular]{Registrierungsformular, Quelle: Autor}
 		\label{img: registerForm}
 	\end{subfigure}
\end{figure} 
 
Die Email-Adresse sowie der Nutzername werden serverseitig auf Einzigartigkeit überprüft. Wie oben erwähnt muss bei jedem Request der passende Header mitgesendet werden. Um dies ohne grossen Aufwand durchführen zu können, wird analog zum Backend ein passendes Tutorial zum Frontend bereitgestellt. Angular bietet die Möglichkeit, mit Auth-Interceptors zu arbeiten. Dieser fügt jedem API Call den entsprechenden Token im Header an. Der Interceptor dient als Proxy. [\cite{authAPIAngular}]

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/authInterceptor.PNG}
	\caption[Authentication Interceptor]{Authentication Interceptor, Quelle: Autor}
	\label{img: authInterceptor}
\end{figure} 
  
Beim erfolgreichen Anmelden wird der Token im \gls{SessionStorage} gespeichert.
Mittels Angular Direktiven wird das Menu für eingeloggte User angepasst. Es wird der Logout Button eingeblendet. Bei einem Klick auf diesen wird der Session Storage gelöscht. 
 
 \paragraph{Automatischer Logout}
 Um die Sicherheit zu erhöhen, wird der Nutzer nach 30 Minuten Inaktivität automatisch ausgeloggt. Für die Umsetzung kam ein das angular-user-idle package zum Einsatz. 
 
 \begin{figure}[H]
 	\centering
 	\includegraphics[scale=0.4]{images/idle.PNG}
 	\caption[Ablauf von Timer und anschliessender Logout]{Ablauf von Timer und anschliessender Logout, Quelle: Autor}
 	\label{img: autoLogout}
 \end{figure} 
Der Timer startet, wenn der Nutzer 10 Minuten inaktiv ist. Anschliessend läuft er 5 Minuten, ehe der Nutzer ausgeloggt wird [\cite{idle}]. 
 
\paragraph{Sprintreview Sprint 5}
 Im Sprint 5 konnte die geplante User Story erfolgreich abgeschlossen werden.
 
\subsubsection{Sprint 6}
\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System ermöglicht die Anbindung an einen bereits bekannten Bezahldienst, 
		um eine sichere Bezahlung zu garantieren.& F.7\\
		\hline
	\end{tabularx} 
	\caption[User Stories Sprint 6]{User Stories Sprint 6, Quelle: Autor}
\end{table}\label{userStoriesSprint6}
\paragraph{Bezahlungsanbieter}
In der Sitzung \ref{04.03.2021} wurde vom Auftraggeber bekannt gegeben, dass sie bei bereits bestehenden Lösungen den Bezahlvorgang mit dem Anbieter Six Payment Services durchführen. 

\paragraph{Einführung}
Six Payment bietet einen Integration Guide an, um die Integration in den eigenen Online Store zu erleichert [\cite{sixECommerce}]. Es wird eine JSON API zur Verfügung gestellt, um die Bezahlung durchzuführen. 
Die Implementierung wurde im Sprint 8 \ref{sprint8} angepasst. 
\subparagraph{Anforderungen}
Das Vorgehen wurde identisch zum empfohlenen Vorgehen auf der Developer Seite durchgeführt. Dabei wurde zur Consultation die \ac{API}-Dokumentation durchgelesen. Nachfolgend werden die wichtigsten Requirements aufgeführt. 
\begin{itemize}
	\item JSON API Basic Authentication
	\item TLS 
	\item mindestens ein aktiver Terminal
	\item Terminal Nummer und Customer Nummer
	\item gütliges acceptance agreement für Kreditkarten
\end{itemize} 
[\cite{jsonAPISix}]
\subparagraph{Data Security}
Um falsche Anwendungen und Missbrauch von Kreditkarten zu verhindern, wurde von den Kreditkartenorganisationen das Sicherheitsprogramm \ac{PCI DSS} ins Leben gerufen. \\
Dieser Standard kann erfüllt werden, wenn die Bezahlung auf dem Saferpay Formular durchgeführt wird. Dieses Formular wird direkt beim Anbieter gehostet. Es werden keine Bezahlungsdaten auf dem eigenen Web Server verarbeitet, gesendet oder gespeichert. Somit ist es auch weniger aufwendig, die \glqq PCI DSS merchant certification\grqq{} zu erhalten [\cite{jsonAPISix}]. 

\subparagraph{Certification Levels}
Die \ac{PCI DSS} Zertifikation ist in verschiedene compliance Level aufgeteilt. Die beiden Wichtigsten sind dabei \ac{SAQ}-A und \ac{SAQ}-A EP. Nachfolgend wird nur \ac{SAQ}-A weiter betrachtet. \\\\
Bei \ac{SAQ}-A wird die Verantwortung vollständig an den Bezahlanbieter abgegeben. Saferpay bietet die Möglichkeit, die erforderlichen Bedingungen zu erfüllen. Die Bedingungen lauten: 
\begin{itemize}
	\item Nutzen von eigenem HTML Formular verboten
	\item Jedes Feld auf der Payment Page muss von einem PCI zertifizierten Anbieter gehosted werden
	\item Änderungen an der Bezahlseite via CSS oder JavaScript sind verboten
\end{itemize}

\subparagraph{Testsystem vs. Livesystem}\label{testvslive}
Saferpay stellt zum Testing einen Testaccount zur Verfügung. Die wesentlichen Unterschiede sind:
\begin{itemize}
	\item Testsystem und Livesystem sind nicht miteinander verbunden
	\item Beim Testsystem werden richtige Kreditkarten nicht akzeptiert
	\item Kein Geld wird beim Testsystem transferiert
	\item Systemverhalten bleibt identisch
	\item URLs sehr ähnlich 
\end{itemize}

\paragraph{Auf Livesystem wechseln}
Um von einem Testsystem auf ein Livesystem zu wechseln, sind einige Änderungen vorzunehmen. 
\begin{itemize}
	\item Authorization Token anpassen
	\item Anpassen von IDs
	\item Anpassen der Request URL
\end{itemize} 

\subparagraph{Allgemeine Informationen}
In diesem Projekt wird nur mit dem Testsystem gearbeitet. Ein Wechsel auf ein Livesystem ist nicht geplant. 
 
 \paragraph{Integration in Web Applikation}
 Um mit der JSON-API kommunizieren zu können, sind im Header des Requests passende Parameter mitgegeben werden. Der korrekte Header sieht folgendermassen aus: 
 \begin{verbatim}
	"Content-Type": "application/json", 
	"Authorization": "Basic QVBJXzI1Nzc1M183NTU3MTMyMjpKc29uQXBpUHdkMV9SalVEQzJzaw==",
 \end{verbatim}
Der Token wird im Testsystem generiert. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/basicAuth.PNG}
	\caption[Erstellen des Basic Authentication Token im Back Office]{Erstellen des Basic Authentication Token im Back Office, Quelle: Autor}
	\label{img: basicAuth}
\end{figure} 
 \subparagraph{Payment Initialization Page}
 An die API muss der entsprechende Request gesendet werden, um den Bezahlvorgang zu starten. Dazu muss der Request an die folgende URL gesendet werden: 
 \begin{verbatim}
 	https://test.saferpay.com/api/Payment/v1/PaymentPage/Initialize
 \end{verbatim}
In der API-Dokumentation ist ein Demo Request zu finden. Die Parameter lassen sich aus dem Backend herauslesen. 
Der Body der Anfrage ist in \ref{img: requestNew} zu finden. 
Es wurde bewusst auf das Erstellen eines entsprechenden TypeScript Interfaces verzichtet. Bei der Antwort war dies nötig, wozu ein passendes TypeScript-Interface erstellt wurde.

Die Anfrage an den Server geschieht asynchron. Somit ist nicht voraussehbar, wann der Request ausgeführt wird, bzw. wann die Antwort gesetzt wird. Jedoch muss in diesem Anwendungsfall auf die URL im Body weitergeleitet werden. Um auf die Antwort zu warten, wurde das selbe Vorgehen wie in \ref{img: observableState} verwendet. 
Nach dem Abschluss der Bezahlung wird entweder auf die Success-URL oder die Fail-URL von obigem Request umgeleitet. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/paymentSaferpay.PNG}
	\caption[Saferpay Bezahlseite]{Saferpay Bezahlseite,\\ Quelle: Autor}
	\label{img: paymentSaferpay}
\end{figure} 

\subparagraph{Payment Assert}
Das Vorgehen zur Bezahlverifikation ist  identisch zur Zahlungsauslösung. 
\begin{verbatim}
	https://test.saferpay.com/api/Payment/v1/PaymentPage/Assert
\end{verbatim}
Um die Bezahlung identifizieren zu können, muss der Token aus vorheriger Antwort mitgegeben werden. Er wird im Session Storage gespeichert. 
Der genaue Request sieht folgendermassen aus: 
\begin{verbatim}
	  let request = {
		"RequestHeader": {
			"SpecVersion": 1.21,
			"CustomerId": this.customerId,
			"RequestId": this.requestId,
			"RetryIndicator": 0
		},
		"Token": this.getToken()
	}
\end{verbatim}
Um das Interface für die Antwort zu definieren, wurde quicktype genutzt. So konnte aus dem Beispielrequest in der Dokumentation das passende Interface generiert werden. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/quickType.PNG}
	\caption[PagePaymentAssertResponse]{PagePaymentAssertResponse, Quelle: Autor}
	\label{img: PagePaymentAssertResponse}
\end{figure} 

Es wird von diesem Request das Status-Property gecheckt. Bei \glqq AUTHORIZED\grqq{} oder \glqq CAPTURED\grqq{} wird die Bezahlung als Erfolgreich markiert. 
Zur Identifikation wird die Request-Id genutzt. Durch diese kann die Bezahlung im Backend eindeutig identifiziert werden. Ein Ausschnitt aus dem Backoffice ist im Anhang \ref{sixPayment} zu finden. 
Der Bezahlprozess ist abgeschlossen. 
\newpage
\paragraph{Ablauf}
Der Bezahlvorgang wird nachfolgend als Sequenzdiagramm dargestellt.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/paymentSequence.PNG}
	\caption[Sequenzdiagramm vom Bezahlvorgang]{Sequenzdiagramm vom Bezahlvorgang, Quelle: Autor}
	\label{img: paymentSequence}
\end{figure} 

\paragraph{CORS}\label{CORS}
\glqq Cross-Origin Resource Sharing (CORS) ist ein Mechanismus, der zusätzliche HTTP Header verwendet um einem Browser mitzuteilen, dass er einer Webanwendung, die auf einer anderen Domain(Origin) läuft, die Berechtigung erteilt auf ausgewählte Ressourcen von einem Server eines anderen Ursprungs(Origin) zuzugreifen. Eine Webanwendung stellt eine cross-origin HTTP-Anfage, wenn sie eine Ressource anfordert, die einen anderen Ursprung(Domain, Protokoll und Port) hat, als ihren eigenen.\grqq{} [\cite{cors}]

Dies wurde auch bei diesem Projekt bemerkt. Die Requests an die \ac{API} von Six wurden von \ac{CORS} geblockt. 

\subparagraph{Setzen von Access Header}
Wenn man Zugriff auf den betroffenen Server hat, kann mittels entsprechenden CORS Headern gearbeitet werden. Das wurde beim eigenen Backend umgesetzt. Da es sich um eine externe API handelt und dementsprechend kein Zugriff auf die Maschine besteht, entfällt diese Möglichkeit. 

\subparagraph{Angular Proxy}
Angular bietet einen eigenen, integrierten Proxy, um \ac{CORS} zu umgehen. Es werden Request mit einer bestimmten Adresse abgefangen und an den passenden Server umgeleitet.\\
In diesem Anwendungsfall funktionierte der Angular Proxy nicht wunschgemäss. Zudem eignet sich dieser nur im Entwicklungseinsatz. 

\subparagraph{Zusätzlicher Proxy auf localhost}\label{corsLocalhost}
Es wurde ein zusätzlicher Node.js-Proxy umgesetzt. Er besitzt keine Logik und nimmt lediglich Requests an, die er an die Adresse im Header weiterleitet [\cite{corsProxy}]. Die Requests werden nun via Proxy an die API gesendet. Zudem wird nun auch mit der eigenen API über diesen Proxy kommuniziert. Dies löst einerseits die \ac{CORS}-Problematik mit externen APIs und macht den Einsatz von HTTPS im Backend \ref{httpsBackend} überflüssig. Der Proxy ist via localhost erreichbar, wobei hier die Mixed Content Policy nicht aktiv ist. Bei der Entwicklung bleibt das Backend direkt erreichbar. Im produktiven Betrieb werden nur Anfragen vom Proxy akzeptiert. 
\newpage
Zudem ist die Verschlüsselung der Kommunikation zwischen Backend und Frontend überflüssig, da sie nur auf der eigenen Maschine abläuft. Es werden keine Daten über eine unsichere Leitung gesendet.
Die Verbindung zur externen API läuft via HTTPS. \\
Angedacht war, dass der Proxy auch im produktiven Umfeld via Loopback-Adresse erreichbar ist. Das bietet den Vorteil, dass Browser dieser trauen und HTTPS überflüssig wird. Der Traffic bleibt nur lokal auf der Maschine, daher bestehen keine Sicherheitsrisiken. Auf Google Chrome sowie auch Firefox funktionierte das. Auf Safari ist die Loopback-Adresse nicht vertrauenswürdig, der Proxy müsste via HTTPS erreichbar sein. Das Problem ist, dass Letsencrypt keine Zertifikate für localhost ausstellt [\cite{letsencryptLocalhost}].\\
Es besteht keine Möglichkeit, dieses Problem unter Safari zu beheben. Der Ansatz musste verworfen werden. 

\subparagraph{Backend als Proxy}
Dieses Vorgehen wird in Sprint 8 \ref{sprint8} genauer beschrieben. 
\paragraph{Problem mit Enterpriselab Host}
Am Mittwoch, 14.04. nachmittags war der GitLab Host nicht mehr erreichbar. Die Nachfrage beim \gls{EnterpriseLab}-Team ergab, dass die Maschine ihre IP-Adresse verloren hatte. Ein Neustart brachte keinen Erfolg, verschiedene wichtige Dienste starteten nicht mehr. Es wurde eine neue Maschine bereitgestellt. Der Grund konnte nicht herausgefunden werden. \\\\
Die Umgebung konnte sehr schnell wieder hergestellt werden. Es mussten nur Docker und GitLab-Runner installiert und registriert werden. Die Daten mussten neu migriert werden. Der Umfang der gesamten Neuumsetzung lag bei ca. 3h. 

\paragraph{Backend Models}
Die Bestellungen sollen im Backend persistiert werden. Bei der Erstellung der Order-Entität fiel dabei auf, dass diese diverse Beziehungen zu anderen Klassen hat. Dadurch wurde entschieden, diese ebenfalls in diesem Sprint zu implementieren. 
 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/erdOrder.PNG}
	\caption[Entity Relationship Diagramm von Order]{Entity Relationship Diagramm von Order,\\ Quelle: Autor}
	\label{img: erdOrder}
\end{figure} 
\newpage
Bei der Implementierung wurde strikt darauf geachtet, dass die gesamte API dem REST-Level 3 nach Richardson Maturity entspricht. Entscheidend dafür ist der Einsatz von \ac{HATEOAS}. 
 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/pickUpJSON.PNG}
	\caption[Response bei Abfrage einer PickUp-Station]{Response bei Abfrage einer PickUp-Station,\\ Quelle: Autor}
	\label{img: responseRequest}
\end{figure} 

Durch den Einsatz von Model Mapper wurde das Mapping von \ac{DTO} und Datenbankobjekt vereinfacht \ref{DTO}. 

\subsubsection{Meilenstein Abschluss Bestellprozess und Zwischenpräsentation}
Nachfolgend werden die Meilensteinberichte zu den Meilensteinen 3 und 4 zusammen aufgeführt. 
 \paragraph{Meilensteinbericht}
 \subparagraph{Termin Meilenstein 3}
 Der Meilenstein 3 ist am 19.04.2021 abgeschlossen und somit pünktlich fertiggestellt worden.
 Der Meilenstein 4 ist am 21.04.2021 abgeschlossen und somit pünktlich fertiggestellt worden. 
 \subparagraph{Beschreibung Meilenstein 3}
 Die Beschreibung des Meilensteins ist im Abschnitt \ref{Meilensteine} ersichtlich. 
 \subparagraph{Meilensteinziele/Vorgaben}
Das übergeordnete Ziel dieses Meilensteins ist die der Abschluss des Bestellprozesses. 
 \begin{itemize}
 	\item Testprotokolle
 	\item Demo
 	\item Release 1
 	\item Zwischenpräsentation
 \end{itemize}
Die Zwischenpräsentation ist im Anhang \ref{zwischenpraesentation}, die Testprotokolle unter \ref{testprotokolleBestellung} zu finden. Zudem ist die Konfigurationseinheit zum Release im Projektmanagementplan unter \ref{release1} aufgeführt. 
 \subparagraph{Meilensteinzielerreichung}
Die Meilensteine konnten grösstenteils erfüllt werden. Einzig die Altersverifikation mittels Jumio wurde nach hinten verschoben. Jedoch ist das Backend bereits sehr weit fortgeschritten.  
Die Zwischenpräsentation wurde erfolgreich durchgeführt. 
 \subparagraph{Fazit}
Es konnten viele der geplanten Artefakte abgeliefert werden. Die fehlende Integration von Jumio wurde durch den Fortschritt im Backend kompensiert. Zudem funktioniert die Bezahlung aufgrund von \ac{CORS}-Problemen nicht auf allen modernen Browsern. Hier muss in den kommenden Sprints nachgebessert werden. 

\subsection{Realisierungsphase}
\subsubsection{Sprint 7}
\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System bietet dem Kunden die Möglichkeit, alle vorhandenen Pick-Up Stations anzuzeigen. & F.8\\
		\hline
		Das System bietet dem Kunden die Möglichkeit, die für ihn nächstgelegene Station auswählen zu können. & F.7\\
		\hline
	\end{tabularx} 
	\caption[User Stories Sprint 7]{USer Stories Sprint 7, Quelle: Autor}
\end{table}\label{userStoriesSprint7}
\paragraph{Anzeigen von Pick-Up Stations}
\subparagraph{Google Maps}
Google Maps gilt als der Standard bei digitalen Karten. Seit einigen Jahren verfolgt Google jedoch ein sehr undurchsichtiges Bezahlmodell. Dem Kunden werden 200 Dollar Kredit pro Monat kostenlos zur Verfügung gestellt. Eine weitere Nutzung würde in diesem Anwendungsfall mit 2 Dollar je 1000 Anfragen belastet. \\
Ausschlaggebend für den Entscheid gegen Google Maps war der Zwang, eine Kreditkarte zu hinterlegen. 
\subparagraph{Geoapify}
Als Alternative zu Google Maps wird Geoapify angeboten. Der Funktionsumfang ist sehr ähnlich, das Hinterlegen einer Kreditkarte wird nicht vorausgesetzt. Bei Geoapify sind 3000 Requests pro Tag kostenlos. 
\subparagraph{Leaflet}
Leaflet ist eine Open Source native Java Script Library für benutzerfreundliche, interaktive mobile Maps [\cite{leaflet}]. 
\subparagraph{OpenLayers}
OpenLayers dient als Alternative zu Leaflet. Dabei ist es für komplexere Applikationen ausgelegt [\cite{leafletVsOpenlayers}]. 
Für dieses Projekt wird nur ein begrenzter Umfang gebraucht, daher wird mit Leaflet gearbeitet. 

\subparagraph{Open Street Map}
Als Karte wird Open Street Map genutzt. Open Street Map untersteht einer freien Lizenz. Die Daten werden hauptsächlich von der Community gepflegt. Die Nutzung bleibt kostenlos. Die Open Street Map Contributors müssen auf der Applikation ersichtlich sein [\cite{openStreetMap}].  
\subparagraph{Anzeigen einer Map mit Leaflet}
Geoapify stellt ein \href{https://www.geoapify.com/angular-leaflet-step-by-step-tutorial-to-add-a-map}{Leaflet-Angular} Tutorial zur Verfügung, um den Einstieg zu vereinfachen . Das Vorgehen von dort wurde übernommen. 

\subparagraph{Marker und Popup Funktionalität}
Die einzelnen Marker werden aus den Daten vom Backend erstellt. Sie werden via Request vom Backend geladen und angezeigt. Zudem werden die entsprechenden Inventories zu jeder Station geladen. Da hier mit \ac{HATEOAS} gearbeitet wurde, waren mehrere \ac{API}-Calls nötig.  \\
Die Produktverfügbarkeit an einer Station sollte als Popup dargestellt werden. Um die Verfügbarkeit darzustellen, wurden entsprechend gefärbte Kreise platziert.  
Beim Anzeigen der Popups ergab sich die Problematik, dass dies auf Apple-Geräten nicht funktionierte. Der Event wurde von Leaflet nicht korrekt erkannt. Nach einigen Recherchen konnte keine Lösung gefunden werden. Ähnliche Fälle sind nicht bekannt. \\
In der Dokumentation von Leaflet ist eine Alternative zu den Popups zu finden. Tooltips werden zum Anzeigen von kleinen Texten auf der Karte genutzt. Der OnClick-Event wird auf allen Geräten korrekt erkannt, das Aussehen ist ähnlich zu den Popups. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/tooltipImp.PNG}
	\caption[Erstellung von Marker und Tooltip]{Erstellung von Marker und Tooltip, Quelle: Autor}
	\label{img: tooltip}
\end{figure} 

 \begin{figure}[H]
 	\centering
 	\includegraphics[scale=0.4]{images/tooltipCard.PNG}
 	\caption[Darstellung von Marker und Tooltip]{Darstellung von Marker und Tooltip, Quelle: Autor}
 	\label{img: tooltipCard}
 \end{figure} 
 
 Ein Problem war, dass die GET-Requests von \gls{RxJS} asynchron ausgeführt werden. Dies bietet einerseits den Vorteil, dass die Applikation während dem Laden von Daten nutzbar bleibt, andererseits ist in diesem Fall essentiell, dass einige Prozesse aufeinander warten. Das Vorgehen wird nachfolgend chronologisch dargestellt: 
 \begin{enumerate}
 	\item Laden von aktueller Location des Benutzers
 	\item Erstellen der Map inkl. Kontrollelemente
 	\item Laden der PickUp-Stations vom Server
 	\item Laden des Inventars vom Server pro PickUp
 	\item Laden von einzelnen Produkten aus dem Inventar
 	\item Hinzufügen von Marker auf die Map 
\end{enumerate}
\newpage
Wie hier zu sehen, sind die Daten voneinander abhängig. So kann das Inventar nicht geladen werden, ohne dass die PickUp Station vorhanden ist und so weiter. Es muss immer auf das Resultat gewartet werden. Um genau das zu ermöglichen, triggered RxJS den State des Observables. Es gibt drei wesentliche Zustände: next, completed und error. 

 \begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/observable.PNG}
	\caption[Observable States]{Observable State, Quelle: Autor}
	\label{img: observableState}
\end{figure} 
\begin{itemize}
\item Next liefert einen Wert, Error einen JavaScript Error oder eine Exception und completed nichts zurück. 
\item Error wird bei den genutzten Abfragen immer direkt mittels pipe abgefangen. \\
\item Mit diesem Vorgehen kann auf das vorhergehende Resultat gewartet werden.
\end{itemize}

\paragraph{Auswahl der PickUp Station}
In Abbildung \ref{img: observableState} ist zu sehen, dass beim Öffnen des Tooltips ein click-Event abgefangen wird. Es wird ein Leaflet Event mitgegeben, welcher unter anderem auch die Koordinaten der geklickten Station enthält. Basierend auf diesen Daten wird die ausgewählte PickUp Station gesetzt. Sie wird im Local Storage des Browsers gespeichert. 
 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/mouseEvent.PNG}
	\caption[Mouse Event]{Mouse Event,\\ Quelle: Autor}
	\label{img: MouseEvent}
\end{figure} 

\paragraph{Benutzerlocation}
Damit der Benutzer direkt beim Start der Karte die nächstgelegene Station sieht, wird sein aktueller Standort abgefragt.\\
Der Standortzugriff wird nicht zwingend für die Benutzung der Applikation benötigt, weshalb beim Blocken des Standortzugriffs eine Default-Location geladen wird. \\
Es bestand zunächst das Problem, dass von der Geolocation API nicht bemerkt wird, wenn die Systemeinstellung dem Browser den Standortzugriff verbieten. Es war hier ein Refactoring nötig, sodass die Applikation auch in diesem Fall funktionsfähig bleibt. 

\paragraph{Sprintreview Sprint 7}
Die \gls{User Story} konnte erfolgreich durchgeführt werden. 

\subsubsection{Sprint 8}\label{sprint8}
\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System ermöglicht die Anbindung an einen bereits bekannten Bezahldienst, um eine sichere Bezahlung zu garantieren.  & F.9\\
		\hline
		Das System bietet die Möglichkeit, eine Bestellung dauerhaft zu speichern. & F.7\\
		\hline
		Das System bietet dem Kunden die Möglichkeit, eine Bestellung durch das Einlesen eines Codes an der Pick-Up Station abzuholen.  & F.16\\
		\hline
	\end{tabularx} 
	\caption[User Stories Sprint 8]{User Stories Sprint 8, Quelle: Autor}
\end{table}\label{userStoriesSprint8}
In diesem Sprint wird das CORS-Problem von Kapitel \ref{CORS} neu angegangen. 

\paragraph{Persistierung der Bestellung}
In einem vorhergehenden Sprint wurden die entsprechenden Methoden und Entitäten für die Erstellung von Orders bereits erstellt. Das Entity Relationship Diagramm \ref{img: erdOrder} liefert einen Überblick. \\
Die Order hat dabei Beziehungen zu den folgenden Entities: 
\begin{itemize}
	\item User
	\item PickUpStation
	\item OrderItem
\end{itemize}
Die Order wird erstellt, sobald der Benutzer auf den Checkout-Button im Warenkorb klickt. Es wird überprüft, ob eine Pick-Up Station ausgewählt wurde und der Warenkorb nicht leer ist. Nach dem erfolgreichen Hinzufügen der Order \ref{img: createOrder} werden die Order-Items erstellt. Hierzu wird pro Item im Warenkorb ein POST-Request durchgeführt \ref{img: createOrderItems}. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/createOrder.PNG}
	\caption[Erstellen der Order]{Erstellen der Order, Quelle: Autor}
	\label{img: createOrder}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/createOrderItems.PNG}
	\caption[Erstellen der OrderItems]{Erstellen der OrderItems, Quelle: Autor}
	\label{img: createOrderItems}
\end{figure}

Der Benutzer wird aus dem Authentifizierungstoken im Backend ausgelesen. 
Nachdem diese Abfragen abgeschlossen sind, wird der Bezahlvorgang ausgelöst. 
\newpage
\paragraph{Inventar}
Jede Station hat bestimmte Inventuren. Das Inventar wird auf der Station maschinell nur sehr selten aufgenommen. Hauptsächlich wird es von der Software gehandhabt.  \\
Es gibt diverse Punkte, welche berücksichtigt werden müssen: 
\begin{itemize}
	\item Sobald mit Bezahlung gestartet wurde, darf der Artikel nicht erneut verkauft werden.
	\item Bei Bezahlungsabbruch muss der Artikel wieder verfügbar sein.
	\item Was passiert mit Artikeln, welche bezahlt sind, aber nicht abgeholt werden?
\end{itemize}
Besonders der erste Punkt aus dieser Auflistung ist sehr wichtig. Stellen wir uns vor, dass ein Produkt an einer Station nur noch ein mal verfügbar ist. Es darf nicht möglich sein, dass zwei Personen dieses Produkt kaufen und auch bezahlen, aber nur eine Person es abholen kann. Das setzt voraus, dass das Inventar in der Datenbank zwingen aktualisiert werden muss, sobald der checkout-Button betätigt wird.\\
Der Nutzer hat aber nun immer noch die Möglichkeit, den Bezahlprozess abzubrechen. In diesem Fall soll das Produkt wieder verfügbar werden. 
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{images/stateMachineOrder.PNG}
 	\caption[Endlicher Zustandsautomat Artikelreservierung]{Endlicher Zustandsautomat Artikelreservierung, Quelle: Autor}
 	\label{img: stateMachine}
 \end{figure}

Das ein Kunde ein Produkt bezahlt und nicht abholt, wird in den seltensten Fällen vorkommen. Dieser Fall wurde nicht weiter bearbeitet. 

\paragraph{Inventar im Frontend}
Bereits bevor der Nutzer die Bestellung platzieren kann, muss im Frontend abgefragt werden, ob die gewünschte Menge verfügbar ist und gegebenenfalls die Auswahl eingeschränkt werden. Bislang wurde nur geprüft, ob ein Artikel an einer Station gar nicht mehr verfügbar ist. Dieses Konzept wird erweitert. \\
Jedem Produkt bei der Auswahl einer Station die Anzahl verfügbarer Produkte zugewiesen. Diese Eigenschaft kann abgefragt werden. Die Bestellung darf nur platziert werden, wenn genügend Produkte an der Station verfügbar sind. \\
Ein Ausnahmefall ist, wenn der Nutzer Produkte im Warenkorb hat, welche an Station A verfügbar sind, aber dann zur Station B wechselt, an der die Produkte nicht verfügbar sind. Dieser Fall wird abgefangen, die Bestellung kann nicht abgeschlossen werden. \\\\
Die Funktionalität wurde in \ref{inventur} getestet. 	 
\newpage
\paragraph{Behebung des CORS-Problems}\label{behebungCors}
Um CORS zu umgehen, wurde ein eigener Node.js-Proxy implementiert und auf die virtuelle Maschine im GitLab deployed. Wie bereits in \ref{corsLocalhost} beschrieben, funktioniert das beim Safari Browser nicht. Der Ansatz mit einem eigenen Proxy wurde verworfen. Dies hing damit zusammen, dass der Reverse-Proxy \ref{reverseProxy} die Anfragen an den Proxy nicht korrekt weiterleitete. Das Problem konnte nicht identifiziert werden. \\\\ Es wurde nach einem neuen Ansatz gesucht, wobei die Wahl auf die Nutzung des eigenen Backends als Proxy fiel. Das Backend übernimmt weitere Aufgaben bei der Bezahlung. So wird der finale Request erst im Backend erstellt, vom Frontend kommt ein leeres Payment Initialize Objekt. In diesem sind nur die Order-Id sowie die redirect-URLs gesetzt. Es wird im Backend aus dem gesendeten, leeren JSON ein entsprechendens Objekt erstellt. Das Erstellen der Klasse wurde analog zu Abbildung \ref{img: PagePaymentAssertResponse} mittels quicktype durchgeführt. Allerdings sind die einzelnen JSON-Properties bei der Saferpay API grossgeschrieben, was nicht mit der Java-Namenskonvention übereinstimmt. Es handelt sich hierbei jedoch nur um DTOs, daher wurde das hier vernachlässigt. 
\begin{figure}[H]
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[scale=0.5]{images/paymentOld.PNG}
		\caption[Payment Initialization alt]{Payment Initialization alt, Quelle: Autor}
		\label{img: requestOld}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[scale=0.5]{images/paymentNew.PNG}
		\caption[Payment Initialization neu]{Payment Initialization neu, Quelle: Autor}
		\label{img: requestNew}
	\end{subfigure}
\end{figure} 
Ausschlaggebend bei diesem Request ist die Order-Id. Sie wird bei der Persistierung der Order gespeichert und im \gls{LocalStorage} gespeichert. Sie wird auch als Request-Id genutzt. Sie ist im gesamten System einzigartig, die Bezahlung kann im Backoffice über diese Id eindeutig identifiziert werden. \\
\subparagraph{Setzen der fehlenden Properties}
Wie in der Abbildung \ref{img: requestNew} zu sehen, beinhaltet der Request nur die Order-Id. Die restlichen Daten werden im Backend gesetzt. Es werden die Werte aus dem \gls{Propertie-File} gelesen und zur Laufzeit den Variablen zugewiesen. 
 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{images/valuesFromProperties.PNG}
	\caption[Auslesen der Werte aus .properties-File]{Auslesen der Werte aus .properties-File,\\ Quelle: Autor}
	\label{img: valuesFromProperties}
\end{figure} 
Der Bestellwert wird ebenfalls im Backend gesetzt. Das macht es unmöglich, dem Bestellwert im Frontend anzupassen und so eine Vergünstigung zu erhalten. Um den Wert zu bestimmen, werden alle OrderItems, die zur Order gehören, in der Datenbank gesucht und der Produktpreis mit der Anzahl Produkte summiert. Dank streams in Java kann das sehr elegant durchgeführt werden. Java empfiehlt den Gebrauch von Atomic Datentypen, wenn Daten mit Streams bearbeitet werden. 
 \begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/calculateTotal.PNG}
	\caption[Berechnung des Order-Totals]{Berechnung des Order-Totals, Quelle: Autor}
	\label{img: orderTotal}
\end{figure} 
Zudem schreibt die API von Six vor, dass der Wert in Rappen, bzw. ohne Kommastellen gesendet wird. 
Durch das DecimalFormat werden die Nachkommastellen entfernt. 

\subparagraph{Senden eines POST-Requests mit Spring}\label{postSpring}
Um einen POST-Request mit Spring an eine andere API zu senden, wurde \gls{RestTemplate} genutzt [\cite{restTemplate}]. Dazu wurde eine HttpEntity mit dem gewünschten Body und dem passenden Header erstellt. Das Erstellen wurde in einen Service \ref{img: httpEntity} ausgelagert. 
\begin{figure}[H]
	\includegraphics[width=1\textwidth]{images/restTemplate.PNG}
	\caption[Senden eines Request mit RestTemplate]{Senden eines Request mit RestTemplate, Quelle: Autor}
	\label{img: restTemplate}
\end{figure}
\begin{figure}[H]
	\includegraphics[width=1\textwidth]{images/httpEntity.PNG}
	\caption[Erstellen der HttpEntity]{Erstellen der HttpEntity, Quelle: Autor}
	\label{img: httpEntity}
\end{figure}

Die Antwort von diesem Request wird vom Backend direkt weitergeleitet. \\Im Frontend wird der Token im \gls{LocalStorage} gespeichert. Er wird bei der Überprüfung gebraucht.
\\
Im nächsten Schritt wird die Bezahlüberprüfung durchgeführt. Wie auch bereits im obigen Beispiel gesehen, werden auch hier die meisten Daten im Backend gesetzt. Hier wird der Token sowie die Request-Id aus dem \gls{LocalStorage} mitgegeben. \\
Als Antwort auf diesen Request wird der Statuscode zurückgegeben. Die Order wird in der Datenbank als bezahlt markiert. 
 \begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/pageAssertReturn.PNG}
	\caption[Überprüfung des Zahlungsstatus]{Überprüfung des Zahlungsstatus, Quelle: Autor}
	\label{img: pageAssertReturn}
\end{figure} 
Er wird im Frontend überprüft, eine entsprechende Meldung ausgegeben und eine Weiterleitung auf das Nutzerprofil durchgeführt. Der Bezahlvorgang ist abgeschlossen.  

\paragraph{Initiale Erstellung von Stations}
Wird eine Pick-Up Station initial eingeschaltet, wird ein POST-Request an das Backend ausgeführt, welcher eine neue Station erstellt. Die \ac{IP}-Adresse wird ausgelesen. Im Backend wird überprüft, ob bereits eine Station mit der selben \ac{IP} vorhanden ist. In diesem Fall wird die bestehende zurückgegeben. Die Station ist noch nicht initialisiert, der Name und die Koordinaten sind zufällig gewählt. Im Frontend ist es dem Administrator möglich, diese Daten einzugeben und die Station zu initialisieren. 
 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{images/initStation.PNG}
	\caption[Initialisierung einer neuen Station]{Initialisierung einer neuen Station,\\ Quelle: Autor}
	\label{img: initStation}
\end{figure} 
Nach dem Erstellen der Station werden die Inventar-Items erstellt. Dazu werden die Daten von der \ac{UART}-Schnittstelle \ref{kommTiny} gelesen und entsprechend zu einem \ac{JSON} umgewandelt. Im Anschluss werden sie an das Backend gesendet. Hier wird überprüft, ob es zu Änderungen im Vergleich zum vorherigen Stand kam und entsprechend die Daten erneuert. 
 \begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/stationInit.PNG}
	\caption[Sequenzdiagramm der Initialisierung einer neuen Station]{Sequenzdiagramm der Initialisierung einer neuen Station,\\ Quelle: Autor}
	\label{img: stationInitSequence}
\end{figure} 
\newpage
\paragraph{Abholung einer Bestellung}
\subparagraph{Erstellen eines QR-Codes}
Bereits in Sprint 1 \ref{SpezifikationSchnittstelleAbholung} wurde spezifiziert, dass zur Abholung ein QR-Code eingelesen werden muss. Um dies umzusetzen, wurde in einem ersten Schritt ein Pick-Up-Identifier der Pick-Up-Station-Entity hinzugefügt. Hierbei handelt es sich um einen 40-stelligen String, welcher bei der Erstellung generiert wird. \\
Dieser String wird mit der Java Library \glqq ZXing\grqq{} in einen QR-Code verpackt. Bei ZXing handelt es sich um die Hauptlibrary, welche bei QR-Codes in Java zum Einsatz kommt. Der Code wird als Buffered Image zurückgegeben. 
[\cite{qrCodeCreation}]
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/qrCodeCreation.PNG}
	\caption[Erstellen eines QR-Code mit ZXing]{Erstellen eines QR-Code mit ZXing, Quelle: Autor}
	\label{img: qrCodeCreation}
\end{figure} 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{images/qrCodeStation.png}
	\caption[QR-Code der Station Luzern Bahnhof]{QR-Code der Station Luzern Bahnhof,\\ Quelle: Autor}
	\label{img: QRCodeStation}
\end{figure}
Dieser Code wird beim finalen Produkt auf der Station positioniert, sodass er gut einlesbar ist. 
Der Token ist für die Abholung an der Station \glqq Luzern Bahnhof\grqq{} geeignet. 

\subparagraph{Lesen des QR-Codes mit Frontend}
Für das Lesen des QR-Codes wurde die reine JavaScript Library \href{https://github.com/cozmo/jsQR}{jsQR} eingesetzt. 
Dabei wurde auf eine Implementierung auf \href{https://stackblitz.com/edit/angular-jsqr?file=package.json}{Stackblitz} zurückgegriffen und diese entsprechend angepasst [\cite{jsQrStackblitz}]. \\
Es bestand lange das Problem, dass anstatt der hinteren Kamera auf die Frontkamera zurückgegriffen wurde. Durch das Hinzufügen des entsprechenden Media-Constraints \begin{verbatim}
video: {facingMode: "environment"}
\end{verbatim} wird per Default auf die hintere Kamera zurückgegriffen. [\cite{mediaStream}]
Damit dies auch Umgesetzt wird, muss das WebRTC adapter-package hinzugefügt werden. 
\subparagraph{Abholmeldung an Backend}
Wenn ein QR-Code gelesen wird, sendet \gls{RxJS} einen Call mit dem Pick-Up Identifier und dem Order-Pick-Up Token an die API. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/pickUpBody.PNG}
	\caption[PickUp Station Identifier und PickUp Token]{PickUp Station Identifier und PickUp Token, Quelle: Autor}
	\label{img: pickUpBody}
\end{figure} 
\newpage
Im Backend kann durch diese beiden Token die Pick-Up Station und auch die Bestellung eindeutig identifizieren. 
Es wird analog zu \ref{postSpring} ein Request an die Pick-Up Station gesendet. Von dieser ist die entsprechende \ac{URL} in der Datenbank vorhanden. Gesendet werden die einzelnen Order Items. 
\subparagraph{Node Server auf Station}\label{nodeStation}
Auf der Pick-Up Station läuft ein Node.js Server. Dieser hat zwei Funktionen: 
\begin{enumerate}
	\item Senden von initialer Nachricht an Backend, wenn Station gestartet wurde
	\item Empfangen von Bestellausgabeanforderungen vom Backend
\end{enumerate}
Bei jedem Neustart der Station wird ein POST-Request durchgeführt und das aktuelle Inventar gesendet. Es handelt sich um Updates, sofern die Daten bereits vorhanden sind. \\
Um die Ausgabeanforderungen empfangen zu können, wurden zudem ein POST-Endpoint erstellt. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/orderPickUp.PNG}
	\caption[Sequenzdiagramm der Bestellabholung]{Sequenzdiagramm der Bestellabholung, Quelle: Autor}
	\label{img: stationBackendCom}
\end{figure} 
\subparagraph{Abschliessende Bemerkungen}
Es wird von der Applikation kein Busy-Waiting genutzt, da der Event vom Backend ausgelöst wird. Die Node.js-Applikation hört nur auf den entsprechenden Port. 
Als Unterschied zu \gls{WebHooks} wird auf die Rückgabe der Meldung gewartet. Gemäss Aussage von der Elektrotechnikseite hält sich diese Wartezeit mit <15 Sekunden sehr stark in Grenzen. Da die Applikation Requests asynchron ausführt, wird die Userexperience nicht beeinflusst.\\
Zudem sind nur sehr wenige Informationen zur Implementation eines eigenen Webhook-Endpoints zu finden. Beinahe alle Dokumentationen befassen sich mit der Nutzung von bereits bestehenden Endpunkten. 

\paragraph{Verbindung zwischen Station und Backend}
Damit die Station vom Backend aus bei einer Abholung angesprochen werden kann, benötigt diese eine fixe, erreichbare Adresse. Heutzutage werden keine öffentlichen IP-Adressen vergeben, bzw. der Preis für ein derartiges Angebot ist entsprechend hoch. Daher wurden verschiedene Alternativen validiert.
\newpage 
\subparagraph{VPN}
Die virtuelle Maschine ist vom VPN des \gls{EnterpriseLab} erreichbar. Der Ansatz bestand darin, das Raspberry Pi ebenfalls in dieses \ac{VPN} zu integrieren, was auch auf Anhieb funktionierte. Ein Ping auf die virtuelle Maschine war auch erfolgreich, jedoch konnte das Pi vom Host nicht erreicht werden. Auf Anfrage gab dass \gls{EnterpriseLab}-Team bekannt, das Verbindungen von der Maschine in das \ac{VPN} aus Sicherheitsgründen von der Firewall geblockt werden [\cite{chatVonUslar:private}]. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{images/enterpriselabVPN.PNG}
	\caption[Ping zwischen Raspberry Pi und Gitlab VM]{Ping zwischen Raspberry Pi und Gitlab VM, Quelle: Autor}
	\label{img: enterpriselabVPN}
\end{figure} 
Auf die Umsetzung eines eigenen VPN-Netzes wurde aus Zeitgründen verzichtet. 
\subparagraph{No-IP}
Vom Betreuer wurde im Meeting \ref{Beteuermeeting2} vorgeschlagen, mit No-IP zu arbeiten. Das Problem bei diesem Lösungsansatz ist, dass im Mobilfunknetz kein Portforwarding möglich ist. Dieses wird aber benötigt, um auf die Adresse zugreifen zu können. Auch diese Lösung musste verworfen werden. 
\subparagraph{zerotier}
Zerotier ist eine Kombination aus \ac{VPN} und \gls{SDWAN}. Es entspricht genau den Anforderungen an das System, eine sichere Verbindung zwischen verschiedenen Geräten zu schaffen. Die Einrichtung war sehr intuitiv und in wenigen Minuten abgeschlossen. Vom \gls{EnterpriseLab} musste der \ac{UDP}-Port 9993 geöffnet werden. Als nächster Schritt wurde ein Konto und ein Netzwerk erstellt. Auf den Clients musste der entsprechende Client installiert werden. Es werden Implementierungen für nahezu jede Plattform angeboten. Die Geräte konnten nun verbunden werden. 
\begin{verbatim}
	sudo zerotier-cli join Netzwerk-ID
\end{verbatim}
Im Admin Panel mussten die Geräte noch bestätigt werden.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/zerotier.PNG}
	\caption[Verbundene Geräte in zerotier]{Verbundene Geräte in zerotier, Quelle: Autor}
	\label{img: zerotier}
\end{figure} 
Es wurden die obigen drei Geräte hinzugefügt, wobei nur die beiden Ersten im Projekt miteinander kommunizieren. Die Entwicklermaschine wurden zum einfacheren Debugging hinzugefügt. \\
Zerotier ist bis zu 50 Geräte kostenlos, es ist ein Administrator verfügbar. Die IP-Adressen sind statisch, die Kommunikation End-to-End Verschlüsselt.

\paragraph{Kommunikation zwischen Pi und Tiny}\label{kommTiny}
Auf der Elektrotechnikseite wird ein Tiny K22 zur Kommunikation mit der Hardware genutzt.\\
Die Kommunikation zwischen Pi und Tiny läuft via \ac{UART}. Um mit Node.js mit seriellen Ports arbeiten zu können, existieren verschiedene Libraries. In einen ersten Versuch wurde \href{https://serialport.io/}{Serial Port} genutzt. 
Die Verbindung zum \ac{UART}-Port konnte erfolgreich hergestellt werden. Das Schreiben auf den Port war auch möglich, die Daten konnten von der Elektrotechnik erfolgreich und vollständig gelesen werden. \\
Beim Lesen der Daten wurden immer nur die ersten 4 Byte angezeigt. Auf Anhieb konnte keine Lösung für dieses Problem gefunden werden, daher wurde ein neuer \gls{Github}-Issue im Serial Port Projekt erstellt. 
\href{https://github.com/serialport/node-serialport/issues/2252}{UART with Raspberry Pi Zero only receiving 4 Bytes}\\\\

Zu einem späteren Zeitpunkt wurde bemerkt, dass das Problem durch den Bluetooth Treiber verursacht wird. Auch wird das Node-Package \href{https://www.npmjs.com/package/raspi-serial}{raspi-serial} verwendet. Hier werden die Daten korrekt gelesen und das Inventar kann erstellt werden. \\
Das Lesen mit dem selben Package umgesetzt. Es werden alle OrderItems in einen String verpackt und auf die \ac{UART}-Schnittstelle geschrieben. 

\begin{figure}[H]
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/sendUartFromTiny.jpeg}
		\caption[Senden von Inventar von Tiny K22]{Senden von Inventar von Tiny K22, \cite{arnoldPhilip:private}}
		\label{img: sendUart}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/uartRead.jpeg}
		\caption[Empfang von Daten auf Raspberry Pi]{Empfang von Daten auf Raspberry Pi, \cite{arnoldPhilip:private}}
		\label{img: readUART}
	\end{subfigure}
\end{figure} 

\begin{figure}[H]
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/sendOrder.jpeg}
		\caption[Senden von Bestellung an Tiny K22]{Senden von Bestellung an Tiny K22, Quelle: \cite{arnoldPhilip:private}}
		\label{img: sendOrder}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/uartEmpfangBestellung.jpeg}
		\caption[Empfang einer Bestellung auf Tiny K22]{Empfang einer Bestellung auf Tiny K22,  \cite{arnoldPhilip:private}}
		\label{img: uartEmpfangBestellung}
	\end{subfigure}
\end{figure} 
\paragraph{Sprintreview Sprint 8}
In diesem Sprint konnten die geplanten Userstories umgesetzt werden. 

\subsubsection{Sprint 9}
\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System bietet die Möglichkeit, durch die Anbindung an eine 3rd Party, eine Altersverifikation durchzuführen.& F.4\\
		\hline
		Das System muss die Punkte in der von Google aufgestellten Core Progressive Web App checklist erfüllen. & F.1\\
		\hline
	\end{tabularx} 
	\caption[User Stories Sprint 9]{User Stories Sprint 9, Quelle: Autor}
\end{table}\label{userStoriesSprint9}

\paragraph{Einlesen der Identitätskarte}
Jumio bietet keine Testversion an. Um die Integration in die Applikation durchführen zu können, wurden vom Auftraggeber der API-Key zur Verfügung gestellt. Zudem hätte die Möglichkeit bestanden, initiale Konfigurationen im Backoffice durchzuführen. Darauf wurde verzichtet, da die gewünschten Einstellungen direkt mit dem API-Call definiert werden können. \\
Jumio bietet eine \gls{Github} Integration Guide an. In diesem wird sehr gut erklärt, wie der initiale Request definiert werden muss. Um einem erneuten \ac{CORS}-Problem vorzusorgen, wurde direkt das Vorgehen von \ref{behebungCors} übernommen. \\

 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/initRequestJumio.PNG}
	\caption[Initialer Request an Jumio API]{Initialer Request an Jumio API, Quelle: Autor}
	\label{img: jumioInitialRequest}
\end{figure} 

Es wird nur die \glqq customerInternalReference\grqq{} und \glqq userReference\grqq{} im Backend gesetzt. Die CustomerInternalReference entspricht dem HashCode des Users, als userReference dient die userId. Zudem ist es vorgegeben, dass die \ac{URL}s via \ac{HTTPS} ausgeliefert werden sowie keine Sonderzeichen enthalten. Die Callback URL wird nicht aktiv genutzt. \\

Als Antwort auf den Request werden die transactionReference, der Timestamp und die redirectUrl zurückgegeben. Wie auch bei der Zahlung wird auf die redirectUrl weitergeleitet. Anschliessend beginnt der Prozess bei Jumio.

Nach dem Abschluss der Altersverifikation wird je nach Status auf die successUrl oder auf die errorUrl weitergeleitet. Im Success-Fall hängt Jumio der Url noch drei weitere Parameter an. Es handelt sich um den Status, die customerInternalReference und transactionReference. \\
\newpage
\subparagraph{Profil sperren}
Aus rechtlicher Sicht ist es essentiell, dass nur Personen, die nachweislich älter als 18 Jahre sind, den Dienst nutzen können. Um dies zu gewährleisten, dass dies erfüllt ist, wurde auf eine Eigenschaft von Spring Security zurückgegriffen. Bei der Nutzererstellung wird ein Objekt vom Typ User Details Implementation erstellt. Dieses implementiert das Interface User Details, in welchem unter anderem Methoden zum Sperren und Aktivieren von Profilen definiert sind. Bei der bisherigen Anwendung wurden diese Methoden überschrieben, ohne explizite Werte zu berücksichtigen. Allerdings bietet sich dieser Anwendungsfall an, um eine eigene Implementation der Methoden durchzuführen. \\
Es wurde die \glqq isEnabled()\grqq{} Methode ausgewählt, da diese dem gewünschten Effekt entspricht. Anstatt das hier nur \grqq true\glqq{} zurückgegeben wird, greift die Methode auf ein Attribut der Klasse UserDetailsImpl zu. 
 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{images/methodIsEnabled.PNG}
	\caption[Überschreiben der isEnabled() Methode]{Überschreiben der isEnabled() Methode, Quelle: Autor}
	\label{img: methodIsEnabled}
\end{figure} 

\paragraph{Altersverifikation}
Die eigentliche Altersverifikation wird nach dem erfolgreichen Einlesen des Ausweises durchgeführt. Die Daten werden von Jumio aus den Bildern ausgelesen und können abgefragt werden. Dazu wird die transaction-Reference benötigt. \\
Ein GET-Request auf die folgende URL liefert diese Daten zurück. 
\begin{verbatim}
	https://netverify.com/api/netverify/v2/scans/
	xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/data
\end{verbatim}
Der entscheidende Wert ist dob (Date of Birth). Im Backend wird die Zeitspanne zwischen jetzt und diesem Datum berechnet. Der Wert muss grösser oder gleich 18 sein, um die Applikation nutzen zu können. 
 \begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/dob.PNG}
	\caption[Altersverifikation]{Altersverifikation, Quelle: Autor}
	\label{img: dob}
\end{figure} 
 
\paragraph{Problem bei Altersverifikation}
Die obige Abfrage liefert eine Fehlermeldung zurück, wenn sie direkt nach der Altersverifikation ausgeführt wird. Jumio braucht eine bestimmte Zeit, bis die Daten verfügbar sind und abgefragt werden können. Dieser Zeitraum liegt zwischen 45 Sekunden und einer Minute. \\
Das Alter kann nur mit diesen Daten verifiziert werden, dieser Schritt muss zwingend durchgeführt werden. Um diese Einschränkung der API zu umgehen, wird nach dem success-Callback der Jumio API von Einlesen des Ausweises asynchron eine Minute gewartet. Dies garantiert, dass Jumio die Daten zur Verfügung stellt. In dieser Zeit kann der Nutzer die Applikation nutzen, das Login ist aber erst nach einer Minute möglich. Es wird im eine Meldung angezeigt, in welcher er über das Verifikationsresultat informiert wird. \\
\newpage
Das Vorgehen ist von Seiten Jumio's sehr schlecht. Der success-Callback sollte erst gesendet werden, wenn die Daten zur Abfrage bereit sind. Im jetzigen Fall wird success ausgegeben, obschon die Transaction ausstehend oder gar incomplete ist. Dies führt zu Fehlern bei der Anwendung der API. 
 \begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/jumioIncomplete.PNG}
	\caption[Jumio Customer Portal Transactions]{Jumio Customer Portal Transactions, Quelle: Autor}
	\label{img: jumioIncomplete}
\end{figure} 

Dennoch konnte die Altersverifikation ausführlich getestet werden. Die entsprechenden Testprotokolle sind unter \ref{altersverifikation} zu finden. Aufgrund der Einschränkungen der API dauert die Altersverifikation mit bis zu einer Minute. 

\paragraph{Sprintreview Sprint 9}
In diesem Sprint konnte nur eine der beiden User Stories abgeschlossen werden. Die \gls{User Story} F.1 wird in den nächsten Sprint übernommen. 
\newpage
\subsubsection{Sprint 10}
\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System muss die Punkte in der von Google aufgestellten Core Progressive Web App checklist erfüllen. & F.1\\
		\hline
		
		\hline
	\end{tabularx} 
	\caption[Userstories Sprint 10]{Userstories Sprint 10,\\ Quelle: Autor}
\end{table}\label{userStoriesSprint10}
\paragraph{Integration von \gls{PWA} Funktionalität}
\subparagraph{Offlinefähigkeit}
Um die Applikation auch ohne aktive Internetverbindung nutzbar zu machen, wurden Service Worker genutzt. Das Hinzufügen zum Projekt übernahm die Angular CLI. 
\begin{verbatim}
	ng add @angular/pwa --project jtiPickUp
\end{verbatim}
Service Worker funktionieren mit dem klassischen ng-serve nicht. Um das Projekt trotzdem lokal testen zu können, gibt es die Möglichkeit, einen lokalen HTTP-Server laufen zu lassen. Um diesen Prozess zu vereinfachen, wurde ein neuer Command im package.json hinzugefügt. 
\begin{verbatim}
	"start-pwa": "ng build --prod && http-server -p 8090 -c-1
	 dist/jtiPickUpStation"
\end{verbatim}
Die Service Worker sind nun aktiv. Dies ist auch in der Developer Konsole von Google Chrome zu sehen. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{images/serviceWorker.PNG}
	\caption[Aktiver Service Worker in Google Chrome]{Aktiver Service Worker in Google Chrome,\\ Quelle: Autor}
	\label{img: serviceWorker}
\end{figure} 

Per Default cached der Service Worker folgende Dateien: 
\begin{itemize}
	\item index.html
	\item favicon.ico
	\item build artifacts
	\item assets 
	\item images und fonts
\end{itemize} [\cite{serviceWorker}]
\newpage
\paragraph{Caching von Request}
Für die Applikation reichte das Speichern der obigen Dateien nur bedingt aus. Damit die App auch Offline benutzbar ist, war es nötig, die Request zu cachen. Angular bietet zwei Arten von Caching an: performance und freshness. Bei Performance werden die Daten immer aus dem cache geladen, sofern sie das maxAge noch nicht erreicht haben. Dies bringt, wie es der Name bereits sagt, einen enormen Performancegewinn. Bei Freshness werden die Daten immer von der API geladen, sofern das Timeout nicht erreicht wurde. Dies garantiert, dass die Daten aktuell sind. Es wird nur im Offline-Fall auf den Cache zurückgegriffen. \\
In der folgenden Tabelle wird aufgezeigt, welche Request von welcher Strategie Gebrauch machen. 

\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{Performance} & \textbf{Freshness} \\
		\hline
		Laden von Produkten& Laden von Inventar\\
		\hline
		& Orders by User\\
		\hline
		& PickUpStations\\
		\hline
	\end{tabularx} 
	\caption[Übersicht über die Verwendung von Freshness und Performance]{Übersicht über die Verwendung von Freshness und Performance,\\ Quelle: Autor}
\end{table}\label{performanceFreshness}
Mit der Performance-Strategie werden ausschliesslich Daten geladen, welche sich nur sehr selten ändern. Die Service Worker haben hauptsächlich zum Zweck, die Applikation Offlinefähig zu machen. Der Performancegewinn ist sekundär. \\\\
Nachfolgend werden noch die Features aufgeführt, welche im Offline-Modus nicht verfügbar sind: 
\begin{itemize}
	\item Login und Registrierung
	\item Platzieren einer Bestellung
	\item Abholen einer Bestellung
\end{itemize}

\paragraph{Anzeigen von Online und Offlinestatus}
Der User sollte auch informiert werden, wenn die Internetverbindung unterbrochen ist. Um dies umzusetzen, wird ein ng-connection-service bereitgestellt. Dieser kann überwacht werden und somit eine Netzwerkveränderung bemerkt werden. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{images/connectionService.PNG}
	\caption[Montoring der Connection-Status]{Montoring der Connection-Status,\\ Quelle: Autor}
	\label{img: connectionState}
\end{figure} 
\newpage
Entsprechend des Status wird eine Meldung in der Applikation angezeigt. Die Meldung in \ref{img: offlineOnline} verschwindet nach zwei Sekunden. 
\begin{figure}[H]
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[scale=0.5]{images/offline.PNG}
		\caption[Offline-Meldung]{Offline-Meldung,\\ Quelle: Autor}
		\label{img: offline}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[scale=0.5]{images/backOnline.PNG}
		\caption[Übergang Offline zu Online]{Übergang Offline zu Online,\\ Quelle: Autor}
		\label{img: offlineOnline}
	\end{subfigure}
\end{figure} 
\paragraph{Favicons}
Das Favicon muss für verschiedene Anwendungsfälle verfügbar sein. Es dient zum Beispiel als App-Icon bei der Installation oder als Tab-Icon im Browsertab. Um die verschiedenen Icons zu erstellen, finden sich im Internet diverse Anbieter. Die Entscheidung fiel auf \href{https://realfavicongenerator.net/}{realfavicongenerator}. 

\paragraph{Install Prompt}
Um dem Nutzer die Möglichkeit zu bieten, die Applikation zu installieren, wurden entsprechende Prompts erstellt.\\
Android bietet die Möglichkeit, die App direkt von Browser zu installieren. Hier wird der Event abgefangen und eine eigene Meldung ausgegeben. Bei iOS existiert so etwas nicht. Daher wird die Anleitung angezeigt, wie die Applikation installiert werden kann [\cite{install}].
\begin{figure}[H]
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[scale=0.12]{images/promptIOS.jpeg}
		\caption[Installation Prompt iOS]{Installation Prompt iOS,\\ Quelle: Autor}
		\label{img: promptIOS}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[scale=0.5]{images/promptAndroid.png}
		\caption[Installation Prompt Android]{Installation Prompt Android,\\ Quelle: Autor}
		\label{img: promptAndroid}
	\end{subfigure}
\end{figure} 

Diese Meldung kann nach einer gewissen Zeit für den Nutzer nervig sein. Es wurde implementiert, dass diese Meldung nur einmal angezeigt wird. Die Entscheidung des Users wird im \gls{LocalStorage} gespeichert. 
\paragraph{Service Worker Update}
Der Service Worker bemerkt, wenn neue Daten vorhanden sind. Es wird zwischen den Events \glqq available\grqq{} und \glqq activated\grqq{} unterschieden [\cite{swupdate}].
\newpage
\paragraph{Lighthouse}
Um die Eigenschaften der Applikation zu messen, bietet Google Chrome in seinen Developer Tools die Möglichkeit, einen Lighthouse Report zu generieren. Es wird die Performance, Accessibility, Best Practices, \ac{SEO} und die \gls{PWA} Funktionalität überprüft. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{images/lighthouseReport.png}
	\caption[Lighthouse Report von der Home Seite]{Lighthouse Report von der Home Seite,\\ Quelle: Autor}
	\label{img: lighthouseReport}
\end{figure} 
Der Report für die Seite gibt an, dass die Performance nur mittelmässig ist. Bei einer genaueren Betrachtung ist das auf die lange Ladezeit beim Largest Contentful Paint zurückzuführen. Es handelt sich um die Zeit, welche benötigt wird, bis das grösste Element angezeigt wird. \\
Als Hauptgrund für einen hohen Wert wird von Google eine langsame Serverantwortzeiten genannt [\cite{lcp}]. Die Maschine wird von \gls{EnterpriseLab} zur Verfügung gestellt, weshalb eine Optimierung nicht möglich ist. Die Daten werden jedoch von einem Service Worker gecached, sodass im Betrieb dieser Wert deutlich tiefer ausfallen wird.\\
Accessibility, Best Practices und \ac{SEO} sind im grünen Bereich, es handelt sich auch um eine \gls{PWA}. 
Die einzelnen Punkte der Checkliste werden im Kapitel \ref{Evaluation} genauer betrachtet. 
\paragraph{Sprintreview Sprint 10}
Die \gls{User Story} im Sprint 10 konnte abgeschlossen werden. 

\subsubsection{Meilenstein Abschluss Realisierungsphase}
\paragraph{Meilensteinbericht}
\subparagraph{Termin Meilenstein 5}
Der Meilenstein 5 ist am 24.05.2021 abgeschlossen und somit pünktlich fertiggestellt worden. 
\subparagraph{Beschreibung Meilenstein 5}
Die Beschreibung des Meilensteins ist im Abschnitt \ref{Meilensteine} ersichtlich. 
\subparagraph{Meilensteinziele/Vorgaben}
Das übergeordnete Ziel dieses Meilensteins ist die der Abschluss der Realisierungsphase. 
\begin{itemize}
	\item Testprotokolle
	\item Demo
	\item Release 3
\end{itemize}
Die Testprotokolle sind im Anhang \ref{testprotokolleBestellung} zu finden. 
\subparagraph{Meilensteinzielerreichung}
Der Meilenstein konnte erfolgreich erreicht werden. Die Kommunikation auf der Station ist noch nicht voll funktionsfähig, an dieser wird im letzten Sprint weiter gearbeitet. 
\subparagraph{Fazit}
Die Realisierungsphase konnte abgeschlossen werden. In der letzten Projektphase werden letzte Tests durchgeführt sowie ein kompletter Systemdurchlauf durchgeführt. 

\subsection{Sprint 11}
\begin{table}[H]
	\setlength\extrarowheight{2pt} % for a bit of visual "breathing space"
	\begin{tabularx}{\textwidth}{|X|l|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System bietet dem Dienstleister die Möglichkeit, bei geringem Warenbestand eine Benachrichtigung zu senden. & F.14\\
		\hline
	\end{tabularx} 
	\caption[User Stories Sprint 11]{User Stories Sprint 11,\\ Quelle: Autor}
\end{table}\label{userStoriesSprint11}
\paragraph{Anzeigen von kritischen Verfügbarkeiten}\label{verfugbarkeiten}
Der Administrator soll zumindest Einsicht haben, wenn ein Produkt eine geringe Verfügbarkeit hat. Umgesetzt wird das durch eine neue Methode auf der \ac{REST}-Schnittstelle. Sie liefert alle Inventuren zurück, bei denen weniger als eine bestimmte Anzahl Produkte vorhanden ist. Diese Information wird als Tabelle in dem Administratorbereich angezeigt. \\
Um eine bessere Übersicht zu haben, wird neu beim Erstellen einer neuen Station per Default für jedes Produkt ein neues Inventar erstellt. Per Default ist die Produktanzahl auf 0 gesetzt. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.2]{images/stationStatus.png}
	\caption[Kritische Verfügbarkeiten auf Stations]{Kritische Verfügbarkeiten auf Stations, Quelle: Autor}
	\label{img: stationStatus}
\end{figure} 

\paragraph{Benachrichtigung}
Die Implementierung einer Benachrichtigung bei einem kritischen Warenbestand könnte mittels Push-Benachrichtigung umgesetzt werden. Ein anderer Ansatz wäre das Senden von einer Email. In beiden Fällen müsste einer Station ein eigener Administrator zugewiesen werden. Im aktuellen Modell ist das nicht implementiert, weshalb dieser Punkt nur konzeptuell umgesetzt wird. \\
Die Implementierung mittels Email wäre einfacher umzusetzen. So könnte nach jeder getätigten Bestellung das Inventar abgefragt werden und im entsprechenden Fall eine Email an die hinterlegte Adresse gesendet werden. \\
Der Ansatz mittels Push-Benachrichtigung ist technisch anspruchsvoller. So muss gewährleistet sein, dass der Administrator zum Zeitpunkt der Meldung angemeldet ist. Eine andere Lösung wäre das Hinterlegen der Geräte-Id. Der Administrator wäre aber an dieses Gerät gebunden, was ein grosser Nachteil ist. \\

Die Implementierung mittels Email wird dem anderen Ansatz vorgezogen. Dies könnte im Backend implementiert werden, es wäre das Bereitstellen eines Mail-Servers nötig. \\
\newpage
\paragraph{Diverse Bugfixes und UI-Verbesserungen}
In diesem Sprint wurden zudem diverse Optimierungen vorgenommen. Diese Änderungen wird nachfolgend aufgelistet: 
\begin{itemize}
	\item Warenkorb
	\item Produktanzeige
	\item Login- und Registrierungsformular
\end{itemize}


\paragraph{Sprintreview Sprint 11}
Um einen Handlungsbedarf beim Inventar zu bemerken, ist der momentane Ansatz ausreichend. Es ist hier zwar ein regelmässiges Abfragen der Daten nötig, für die prototypische Umsetzung reicht dies aber aus. 
 \subsection{Einführungsphase}
 In der Einführungsphase wurde die Software mit dem Auftraggeber eingerichtet. Es wurden kleine Punkte zur Verbesserung vorgeschlagen und auch umgesetzt. \\
 In einem ersten Schritt wurde die Software an Ralf Hohermuth übergeben. Auf Ralfs Wunsch hin wurden einige Anpassungen vorgenommen. So werden die Preise neu mit CHF bezeichnet. Zudem werden die Packshots nicht immer angezeigt und die Grenze bei der Anzeige der Verfügbarkeiten soll neu gesetzt werden. \\
 Die Meisten dieser Punkte waren sehr einfach umzusetzen. Die Anzeige der Packshots funktioniert in seltenen Fällen nicht, es aber kein Muster zu erkennen. Es wird davon ausgegangen, dass es sich hier um einer Fehler vom Angular Service Worker handelt. Dieser Status wird im \gls{LocalStorage} gespeichert. Die neue Grenze für die Verfügbarkeit liegt bei 3 Produkten. Bei null Produkten wird die Anzeige rot, zwischen 1-3 orange und darüber hinaus grün. \\\\
 Es wurde der finale Release \ref{release3} erstellt. Die restliche Zeit in dieser Projektphase wurde für die Bearbeitung der Dokumentation genutzt. 


\newpage
