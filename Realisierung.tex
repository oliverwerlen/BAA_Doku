% !TEX root = PREN2_Dokumentation.tex
\section{Realisierung}\label{realisierung}
\subsection{Initialisierungsphase}
\subsubsection{Kick-Off Meeting}
Das Kick-Off Meeting fand am 23.02.2021 als Zoom Meeting statt. Das Sitzungsprotokoll dazu ist im Kapitel \ref{kickOff} zu finden. \\
Es waren bei diesem Meeting alle Projektbeteiligten anwesend. In erster Linie wurde von Herr Meier das genaue Vorgehen bei der Bachelorarbeit vorgestellt. Anschliessend stellte der Auftraggeber das Projekt genauer vor und zeigte dabei seine Erwartungen auf. Die Aufgabenstellung wurde finalisiert und von allen Projektbeteiligten akzeptiert. Zudem schlug der Betreuer vor, im zwei bis drei Wochenrythmus ein Meeting abzuhalten. Im Anschluss wurde ein Termin für das erste Meeting vereinbart. 
\subsubsection{Erstellen des Projektmanagementplans}
Gemäss \ac{SoDa} wurde in einem ersten Projektschritt der Projektmanagementplan \ref{Projektmanagementplan}erstellt. In diesem wurde auch gleich der Rahmenplan erarbeitet. In diesem sind unter anderem die Meilensteine des Projekts dargestellt. Der Projektstrukturplan erleichterte dabei das Finden. Sie wurden in einem nächsten Schritt genauer spezifiziert und die Deliverables für ein erfolgreiches Erreichen des Meilensteins definiert. Durch den Projektstrukturplan konnten die einzelnen Teilbereiche des Projekts aufgelistet werden.
In der folgenden Risikoanalyse wurden die Risiken und entsprechenden Gegenmassnahmen erarbeitet. \\
Als letztes wurde die Projektunterstützung genauer spezifiziert. Dabei wurden die zu verwendenden Tools sowie die Elemente der Konfigurationseinheit festgelegt. \\
Als letzter Teil des Projektmanagements wurde die Teststrategie und die Testdrehbücher formuliert. Die Testdrehbücher werden während des Projekts vorlaufend formuliert. 

\subsubsection{Problem und Vision}
Das Kapitel \ref{Problem} wurde zum Beginn der Initialisierungsphase bearbeitet. Die Hauptprobleme konnten dabei sehr schnell gefunden werden. Die Vision des Projektes konnte mithilfe der Aussagen des Auftraggebers im Kick-Off Meeting \ref{kickOff} sehr gut beschrieben werden. 
\subsubsection{Requirement Engineering}
Beim Requirements Engineering diente die IEEE Spezifikation 29148-2018 als Grundlage [\cite{ieeeSrs}]. Um die Requirements zu finden, wurde in einem ersten Schritt eine Analyse der Aufgabenstellung durchgeführt. Ergänzt wurden diese durch Befragungen des Auftraggebers. Durch die so erlangten Informationen konnten die Anforderungen formuliert werden. In einem letzten Schritt wurden diese mit dem Auftraggeber besprochen. Hierbei wurden noch einige Anpassungen gemacht. 
\subsubsection{Stand der Technik}
In diesem Kapitel wurde eine Analyse der bestehenden, vergleichbaren Lösungen durchgeführt. Dabei wurde vorallem das Angebot der Post und von Valflora genauer betrachtet. Die bekannte \ac{PWA} von Starbucks zeigte dabei sehr gut deren Möglichkeiten auf. 
\subsubsection{Meilenstein Abschluss Initialisierungsphase}

\paragraph{Meilensteinbericht}
\subparagraph{Termin Meilenstein 2}
Der Meilenstein 2 ist am 07.03.2021 abgeschlossen und somit pünktlich fertiggestellt worden.
\subparagraph{Beschreibung Meilenstein 2}
Die Beschreibung des Meilensteins ist im Abschnitt \ref{Meilensteine} ersichtlich. 
\subparagraph{Meilensteinziele/Vorgaben}
Das übergeordnete Ziel dieses Meilensteins ist die Fertigstellung der Initialisierungsphase.
Hierzu war die Auslieferung der nachfolgenden Artefakte notwendig:
\begin{itemize}
	\item Projektmanagementplan
	\item Systemspezifikation
	\item Anforderungsliste
\end{itemize}
Zusätzlich wurden bereits die Kapitel \ref{Problem} und \ref{StandDerTechnik} fertiggestellt. 
\subparagraph{Meilensteinzielerreichung}
Es konnten alle geforderten Artefakte geliefert werden. Die Artefakte wurden bereits mit der Betreuungsperson im Meeting \ref{Beteuermeeting1} besprochen und konnten abgenommen werden. 
Der Meilenstein wurde erfolgreich erreicht. 
\subparagraph{Fazit}
Es wurden alle Artefakte erarbeitet. Der Meilenstein wurde somit erreicht und es kann weiter nach Plan gearbeitet werden.
\subsection{Konzeptionsphase}
\subsubsection{Sprint 1}\label{Sprint1}
\begin{table}[H]
	\begin{tabularx}{\textwidth}{|l|X|}
		\hline
		User Story & Number \\
		\hline
		Das System ist auf eine physische Pick-Up Station abgestimmt. & F.2\\
		\hline
	\end{tabularx} 
\caption[Userstories Sprint 1]{Userstories Sprint 1,\\ Quelle: Autor}
\end{table}\label{userStoriesSprint1}

\paragraph{Spezifikation der Schnittstelle zur Abholung}\label{SpezifikationSchnittstelleAbholung}
Um eine Abholung der Produkte zu bekommen, braucht es eine Kommunikation zwischen der \ac{PWA} und der Pick-Up Station. Um diese Schnittstelle genauer spezifizieren zu können, war es in einem ersten Schritt nötig, eine entsprechende Übertragungstechnologie festzulegen. Bei der Auswahl war dabei die Kompatibilität mit verschiedenen Geräten und Browsern ausschlaggebend. 
\subparagraph{NFC}
Als eine erste Idee wurde \ac{NFC} analysiert. \ac{NFC} eignet sich dabei ideal für die Übertragung von geringen Datenmenge. Dabei funktioniert es bis zu einer Distanz von 10cm. Die Umsetzung wäre dabei sehr einfach mittels einem Raspberry Pi umsetzbar. Einfache \ac{NFC}-Leser gibt es dabei schon für wenig Geld zu kaufen. Dabei könnte die gesamte Übertragung von der Informatik übernommen werden, eine weitere Schnittstelle zwischen Elektrotechnik und Informatik könnte dabei vermieden werden.  \\Die Technologie ist dabei sehr robust. Ein Überkleben oder Zerkratzen des Lesers hat keinen Einfluss auf die Funktionalität  [\cite{nfc}]. 
Der Abholvorgang wäre sehr einfach und schnell, da nur ein kurzer Kontakt mit dem Smartphone bereits ausreicht. 
\subparagraph{Kompatibilität}  
Apple schränkt den Zugriff von Webpages auf Standort-und Hardwaredienste unter iOS-Geräten sehr stark ein. Offiziell begründet wurde dies durch die Einschränkung von footprinting und des damit verbundenen Nutzertrackings. Für dieses Projekt ausschlaggebend ist dabei vor allem das Entfernen von NFC- und Bluetooth-Support. Somit ist es auch \ac{PWA}'s nicht mehr möglich, unter iOS auf die genannten Funktionen zuzugreifen [\cite{webKitTracking}].\\
Die Web-NFC-API wird zusätzlich bislang nur von Google Chrome unterstützt. Dies würde die Nutzbarkeit der Applikation sehr stark einschränken [\cite{kompWebNFC}]. 
Aus diesem Grund eignet sich \ac{NFC} nicht für die Verwendung in diesem Projekt. 
\subparagraph{QR-Code}\label{qrcode}
Die Restriktionen von Apple schränken die geeigneten Technologien sehr stark ein. Es bleibt nur noch der Zugriff auf die Kamera, um mit der Pick-Up Station zu kommunizieren. Ursprünglich war dies vom Auftraggeber nicht gewünscht. Das Verwenden einer anderen Technologie würde aber viel zu viele Einschränkungen führen, sodass die \ac{PWA} mit vielen Geräten unbrauchbar wäre. \\
Aus diesem Grund musste ein Konzept entwickelt werden, um die Warenausgabe mittels QR-Code auszulösen. Dabei sind zwei Ansätze möglich: 
\begin{itemize}
	\item Fixer QR-Code auf Pick-Up Station, wird von \ac{PWA} eingelesen. 
	\item Variabler QR-Code in \ac{PWA}, wird von Pick-Up Station eingelesen. 
\end{itemize}
Aus hardwaretechnischer Sicht ist die Umsetzung der ersten Lösung bedeutend einfacher Umzusetzen, bietet aber auch Fehlerpotential. Ein Überkleben des QR-Codes auf der Station würde die gesamte Station unbrauchbar machen. Eine Abholung der Bestellungen wäre nicht mehr möglich. \\
Die zweite Variante ist hardwaretechnisch anspruchsvoller. Auf der Pick-Up Station muss ein optischer Leser verbaut werden. Mit diesem kann der QR-Code aus der \ac{PWA} eingelesen und die Bestellung ausgegeben werden. \\

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/QR-CodeOnMachine.jpg}
	\caption[Beispielanwendung QR-Code auf Gerät]{Beispielanwendung QR-Code auf Gerät,\\ Quelle: \cite{imageQRCodeTwint}}
	\label{img: Beispielanwendung QR-Code auf Geraet}
\end{figure}
Eine Grafik zum zweiten Lösungsansatz ist dabei im Kapitel \ref{avecBox} zu finden. 
Die genaue Wahl wird im Meeting mit dem Auftraggeber besprochen und abgesegnet. 

\subsubsection{Sprintreview Sprint 1}
Im Sprint 1 wurde eine genauere Analyse der Schnittstelle zur Produktabholung durchgeführt. Dabei müssen im Meeting von dieser Woche die gefundenen Lösungen mit dem Auftraggeber besprochen werden. Die Userstory kann erst zu Beginn des nächsten Sprints abgeschlossen werden. 

\paragraph{Meilensteinbericht}
\subparagraph{Termin Meilenstein 3}
Der Meilenstein 3 ist am 18.03.2021 abgeschlossen und somit mit drei Tagen Verspätung fertiggestellt worden. 
\subparagraph{Beschreibung Meilenstein 2}
Die Beschreibung des Meilensteins ist im Abschnitt \ref{Meilensteine} ersichtlich. 
\subparagraph{Meilensteinziele/Vorgaben}
Das übergeordnete Ziel dieses Meilensteins ist die Fertigstellung der Initialisierungsphase.
Hierzu war die Auslieferung der nachfolgenden Artefakte notwendig:
\begin{itemize}
	\item Projektmanagementplan
	\item Systemspezifikation
	\item Anforderungsliste
\end{itemize}
Zusätzlich wurden bereits die Kapitel \ref{Problem} und \ref{StandDerTechnik} fertiggestellt. 
\subparagraph{Meilensteinzielerreichung}
Es konnten alle geforderten Artefakte geliefert werden. Die Artefakte wurden bereits mit der Betreuungsperson im Meeting \ref{Beteuermeeting1} besprochen und konnten abgenommen werden. 
Der Meilenstein wurde erfolgreich erreicht. 
\subparagraph{Fazit}
Es wurden alle Artefakte erarbeitet. Der Meilenstein wurde somit erreicht und es kann weiter nach Plan gearbeitet werden.

\subsubsection{Sprint 2}\label{sprint2}
\begin{table}[H]
	\begin{tabularx}{\textwidth}{|l|X|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System ist auf eine physische Pick-Up Station abgestimmt. & F.2\\
		\hline
		Das System bietet dem Kunden die Möglichkeit, verschiedene Produkte zu bestellen. & F.6\\
		\hline
		Das System muss über eine CI/CD-Pipeline verfügen. & L.6 \\
		\hline
	\end{tabularx} 
	\caption[Userstories Sprint 2]{Userstories Sprint 2,\\ Quelle: Autor}
\end{table}\label{userStoriesSprint2}

\paragraph{CI/CD Pipeline}
Nach Absprache mit dem Auftraggeber im Meeting wurde entschieden, dass der Prototyp im EnterpriseLab laufen soll. Daraufhin wurde eine Maschine beantragt. Es handelt sich hierbei um ein Ubuntu 16.07 LTS. Die Applikationen sollen dabei als Docker Container deployed werden. \\
Zuerst wurde geplant, die Pipeline wie im offiziellen Tutorial des Enterpriselabs zu erstellen. Auf Anfrage wurde jedoch ein anderes Vorgehen empfohlen. Nachfolgend wird die Antwort zitiert.  \\\\
"Wenn es dein Ziel ist eine Spring Boot Applikation zu builden und dann auf der VM zu deployen dann würde den Container auf den Shared Runner unserer GitLab Instanz builden lassen und in die Container Registry deines Projekts pushen. Für die Deploy Stage der CI/CD Pipeline kannst du deine VM als privaten GitLab Runner registrieren und so ohne SSH login den Container von der Registry pullen und laufen lassen. Die SSL Termination mit Lets Encrypt würde ich mit einem separaten nginx Container lösen der reverse proxy spielt. Dieser kann dann einfach laufen und muss für Änderungen an der Spring Boot Applikation auch nie modifiziert werden.

Der Vorteil im Vergleich zur Docker Übung ist, dass hier alle Hosts von der GitLab CI/CD Pipeline kontrolliert werden. In der Übung ist der docker-cloud-exercise Host abgekapselt und pullt mit Watchtower einfach blind das neuste Image von einer Registry. Dieser Aufbau macht IMO mehr Sinn wenn man einfach Container Images von dritten konsumiert, aber ist weniger elegant wenn man selbst Kontrolle über die Source und CI/CD Pipelines hat." [\cite{emailEnterpriselab:private}]

In diesem Auszug aus der Email vom Enterpriselabmitarbeiter Cyrill von Uslar sind sehr viele Informationen enthalten. Es war ein mehrmaliges Durchlesen nötig, um sich darunter etwas vorstellen zu können. Anschliessend wurde die Pipelineerstellung in die wesentlichen Punkte aufgeteilt um umgesetzt.
\begin{itemize}
	\item Builden auf dem Shared Runner 
	\item Pushen in die Container Registry des Projekts
	\item VM als privaten Runner registrieren und deployen
	\item nginx server als reverse Proxy für SSL Termination
\end{itemize}

\subparagraph{Builden auf dem Shared Runner}
In diesem Projekt wird die Pipeline für zwei Projekte aufgesetzt. In einem ersten Schritt wurde dies nur für die Spring Applikation durchgeführt. 
Das Vorgehen unterscheidet sich dabei nur im Buildprozess. 
Um die Spring Applikation zu Builden, wurde das Dockerfile identisch zum Spring Boot Docker-Tutorial aufgebaut [\cite{springBootDocker}

\begin{verbatim}
FROM maven:3.6.3-jdk-11-slim
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]
\end{verbatim}
Entgegen dem Tutorial, in welchem noch die Java Version 11 genutzt wird, kommt hier direkt Java 16 zum Einsatz. \\\\
Anschliessend wurde das .gitlab-ci.yml File erstellt. Es wurde hier eine Anleitung aus dem Gitlab Blog genutzt. Diese ist jedoch nicht mehr ganz aktuell. Das Deployment wird hier zudem auf ein Kubernetes Cluster durchgeführt. Es musste daher individuell angepasst werden. Es konnte somit nur der Build-Teil übernommen werden. [\cite{springBootCI}]\\
Gitlab stellt zum Builden von Docker-Images bereits mehrere Shared-Runner zur Verfügung. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/gitLabRunner.png}
	\caption[Verfügbare Shared-Runner von GitLab]{Verfügbare Shared-Runner von GitLab,\\ Quelle: Autoren}
	\label{img: runnerGitlab}
\end{figure}
Der jeweilige Runner wird dabei mittels eines "fair usage algorithms" zugewiesen. Dabei ist die Anzahl der momentan auszuführenden Jobs pro Projekt entscheidend für die Wahl. Das Projekt mit den am wenigsten laufenden Jobs kommt zuerst. [\cite{runnersGitlab}] Zudem achtet der runner auf die verwendeten Tags. In diesem expliziten Beispiel sind mehrere Runner mit dem Docker-Tag versehen. Daher kann nicht sicher gesagt werden, welcher Runner den Docker Build durchführt. 
\subparagraph{Builden in die Registry des Projekt}
Um das erstellte Image in die Registry des Projekts zu pushen, werden von GitLab bereits die einzelnen Befehle vorgegeben. Diese können in die package-Stage integriert werden. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/gitLabRegistry.png}
	\caption[CLI Commands GitLab Container Registry]{CLI Commands GitLab Container Registry,\\ Quelle: Autoren}
\label{img: containerRegistryGitlab}
\end{figure}

Das entsprechende Image wird so in die interne Container Registry des GitLab Projekts gepushed. Dadurch kann auf das Verwenden eines Drittdienstes wie DockerHub verzichtet werden. 
Beim Build werden immer zwei Images in die Registry geschrieben. Einerseits eines mit dem Tag "latest" und eines mit dem Commit-Hash als Tag. Beim Deployment wird dann immer das Image mit dem aktuellen Commit-Hash verwendet. Dieser Mechanismus dient dazu, dass alle Versionen immer vorhanden sind. "Latest" zeigt dabei immer auf die aktuelle Version. 

\subparagraph{VM als privaten Runner registrieren und deployen}
Um das Deployment ohne Watchtower durchführen zu können, wurde auf die Virtuelle Maschine als Docker-Runner hinzugefügt. Es handelt sich somit dabei um einen specific Runner. 
GitLab Runner kann dabei einfach mittels Paketmanager auf Ubuntu installiert werden. Anschliessend musste dieser noch konfiguriert werden. Dazu musste der Token sowie die URL von GitLab dem Runner hinzugefügt. Der Runner ist anschliessend im Runner Bereich des Projekts zu finden. Zudem wurde anschliessend die Option "Lock to current projects" enfernt, sodass dieser Runner auch direkt für das Angular Projekt genutzt werden kann. 
Um ein SSH-Login zu vermeiden, wurde der Executor dabei als Shell-Executor definiert. Bei einem SSH-Executor wäre vorgängig die Verbindung via SSH nötig gewesen. 
Anschliessend können die entsprechenden Befehle für das Deployen in das gitlab-ci.yml integriert werden. Dabei war es zunächst ein Problem, dass die Berechtigung fehlte. Erst nach dem Login mittels GitLab CI-Token konnte der Container erfolgreich gepulled und anschliessend gestartet werden. 

\subparagraph{Build und Deployment des Frontends}
Um mit dem nächsten Schritt weiterzufahren, musste zuerst das Deployment des Angular Projekts konfiguriert werden. Hierbei liegt der Hauptunterschied in dem Build-Prozess. Dabei ist es wichtig, die beim Build entstehenden Artifakte in GitLab zu speichern. Nur so kann auf ein erneutes Builden beim Erstellen des Docker Containers verzichtet werden. Zudem werden die Node Module in den Cache gespeichert. Die nachfolgenden Befehle sind identisch zum Vorgehen bei Spring.  

\subparagraph{nginx als Reverse Proxy}\label{reverseProxy}
Um den nginx-Server gegen Zugriffe von Aussen zu schützen, wurde auf einen Reverse Proxy gesetzt. Der Reverse Proxy stellt dabei die einzige Verbindung ins öffentliche Netz dar. Zudem übernimmt er die Zertifikatsverwaltung des Frontends. Alternativ wäre auch ein Caching möglich, auf die Umsetzung wurde für diesen Anwendungsfall jedoch verzichtet. [\cite{reverseProxy}] \\\\

Die Umsetzung wurde dabei analog zum Tutorial von Alexander Bohndorf durchgeführt. [\cite{confReverseProxy}] Dabei wurde der nginx-proxy von jwilder sowie die damit kompatible letsencrypt companion verwendet. Die Umsetzung wurde dabei mittels docker-compose Files durchgeführt. 

\paragraph{Abschliessende Bemerkungen}
Das Erstellen der CI/CD Pipelines des Projekts verlief grösstenteils problemlos. Durch die Grundlage des Enterpriselabs und der sehr guten Dokumentation von GitLab konnte dies sehr schnell umgesetzt werden. Durch das Hinzufügen des Reverse Proxies konnte die Sicherheit des Systems massiv erhöht werden. Zusätzlich wurde so auch gleich die Auslieferung via HTTPS hinzugefügt sowie für ein immer gültiges Zertifikat gesorgt. \\
Beim Backend wurde auf eine zusätzliche Test-Stage verzichtet. Die gesamten Tests werden bereits im Maven-Build ausgeführt. Beim Frontendprojekt wurde dazu eine eigene Stage für e2e Tests festgelegt. 
Die fertigen Konfigurationen sind im GitLab Projekt enthalten und können dort eingesehen werden. 

\paragraph{Bestellen von Produkten}\label{order}
Um eine Bestellung durchführen zu können, wurde in einem ersten Schritt das Article Object definiert. Basierend auf diesem wurde das passende \ac{DTO} definiert. Um das Mapping zwischen DTOs und Objekt zu vereinfachen, wurde der Object Mapper modelmapper genutzt. 
Zudem wurde direkt mit \ac{HATEOAS} gearbeitet. Der Controller stellt dabei die gewohnten CRUD-Operationen zur Verfügung. \\

\paragraph{Abstimmung auf physische Pick Up Station}\label{abstimmungPickUp}
Im Meeting von dieser Woche wurden dem Auftraggeber die beiden in Kapitel \ref{qrcode} erarbeiteten Lösungen vorgestellt. Der Entscheid fiel dabei zugunsten der ersten Alternative. Dabei befindet sich der QR-Code fix auf der Station. Diese ist deutlich robuster und einfacher umzusetzen. \\\\
Die Schnittstellen zwischen Elektrotechnik und Informatik sind essentiell für die Funktionalität des Endprodukts. Aus diesem Grund wurde in diesem Sprint ein Meeting zwischen den Projektbeteiligten einberufen. Besonders das Senden der Ausgabeanforderung führte dabei zu Problemen. Hierbei soll auf einen Busy-Waiting Ansatz verzichtet werden. Jedoch soll die Lösung auch sehr energiesparend und effizient umsetzbar sein. Da beide Beteiligten keine Erfahrung im \ac{IoT}-Umfeld besitzen, wurde hier der Betreuer Michael Handschuh um Hilfe gebeten. 


\subsubsection{Sprintreview Sprint 2}
In Sprint 2 konnten nicht alle User Stories vollständig erfüllt werden. Es werden daher zwei von drei User Stories im nächsten Sprint weiter bearbeitet. Die Umsetzung der CI/CD Pipeline ist hingegen abgeschlossen. Dies war auch die Hauptarbeit in diesem Sprint. Für die Spezifizierung der Schnittstelle wird beim Meeting mit dem Betreuer eine geeignete Lösung erarbeitet. Bei dem Bestellprozess ist bereits die Abfrage von Produkten an der API möglich. In einem nächsten Schritt wird das passende Frontend entworfen und umgesetzt. 

\subsubsection{Sprint 3}
\paragraph{User Stories}
In diesem Sprint wurden keine neuen User Stories zum Sprint Backlog hinzugefügt. Es wird weiterhin an den beiden verbleibenden User Stories gearbeitet. 

\paragraph{Abstimmung auf eine physische Pick Up Station}
Bei der Abstimmung auf die physische Pick Up Station musste das geplante Vorgehen mit dem Projektbetreuer besprochen werden. Im Meeting \ref{Beteuermeeting2} wurde eine geeignete Lösung gesucht. Dabei standen zwei Möglichkeiten zur Auswahl. 
\subparagraph{WebHooks}
WebHooks werden dabei zur Kommunikation zwischen zwei Diensten genutzt. Das Vorgehen ist dabei vergleichbar mit dem aus der Programmierung bekannten Observer Pattern. Dabei wird das Push-Verhalten genutzt. Es sind keine Requests nötig, um allfällige neue Daten zu bemerken. Die API pusht die Daten zum WebHooks-Endpoint. Der Event wird dabei mit POST-Request ausgelöst. Dabei wird Webhooks auch von diversen Zahlungsanbietern wie PayPal genutzt. Es handelt sich hierbei um eine asynchrone Kommunikation. [\cite{webhooksExplained}] WebHooks erfüllt dabei alle Anforderungen, welche zur Kommunikation zwischen API und PickUp Station benötigt werden.  \\Allerdings ist noch keine Erfahrung mit WebHooks vorhanden. Jedoch kann zur Erstellung auch Node.js mit Express verwendet werden. Dieses ist bekannt und wurde auch schon in anderen Projekten genutzt. 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/webhooks_fun.png}
	\caption[Webhooks Funktionsweise]{Webhooks Funktionsweise,\\ Quelle: \cite{webhooksImage}}
	\label{img: webhooks_fun}
\end{figure}

Sobald die entsprechende User Story bearbeitet wird, wird der entsprechende WebHooks-Endpoint erstellt. 

\paragraph{Produktbestellung}
In diesem Sprint wurde zudem an der Produktbestellung gearbeitet. Als Erstes wurde das Darstellen von Produkten ins Auge gefasst. Zudem wurde die Grundstruktur der Angular Applikation erstellt. 
Dabei wurde strikt nach dem Mobile First Ansatz gearbeitet. Durch Schemantic konnte das responsive Menu sowie die Anzeige für die Produkte sehr schnell erstellt werden. Im Anschluss wurde das Menü mit den gewünschten Inhalten gefüllt. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{images/nav.png}
	\caption[Navigation]{Navigation,\\ Quelle: Autor }
	\label{img: navigation}
\end{figure}

Bei den Produkten wurde das Card Element von Angular Material gesetzt. Dieses wurde in ein Grid Layout verpackt. Damit die Seite auf allen Geräten optimal aussieht, wird das Layout basierend auf der Displaygrösse angepasst. Um dies mit TypeScript umzusetzen, wurde ein Breakpoint Observer eingesetzt. Mithilfe von diesem wird die Anzahl Spalten und die Spaltenhöhe abhängig von der Geräteauflösung festgelegt. Sie wird dabei beim Laden der Seite festgelegt. Es ist hier kein Listener Mechanismus nötig, da sich die Auflösung nicht während der Laufzeit ändert.\\ Um die Anzahl Spalten bei einem Wechsel in den Landscape Modus anzupassen, wurde ein neuer Observer eingesetzt. Dieser legt die entsprechende Anzahl fest. 
\begin{figure}[h]
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/rowsLand.PNG}
		\caption[Observer, Wechsel Landscape/Portrait Tablet]{Observer, Wechsel Landscape/Portrait Tablet,\\ Quelle: Autor}
		\label{img: Landscape observer}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.6]{images/rowsRes.PNG}
		\caption[Spaltenanzahl- und Höhe abhängig von Auflösung]{Spaltenanzahl- und Höhe abhängig von Auflösung,\\ Quelle: Autor}
		\label{img: Resolution Observer}
	\end{subfigure}
\end{figure} 

\subparagraph{Anzeige der Produkte}
Die Abfrage der Produkte war bereits in einem vorderen Sprint \ref{order} im Backend erstellt. Ergänzend dazu wurde ein Image Controller definiert. Dieser ermöglicht es, via dem Bildnamen das passende Bild zu erhalten. Bei der Abfrage eines Produkts wird dieser dabei als Link mitgesendet. Die Produkte wurden analog zur Java Klasse als TypeScript Klasse definiert. Die Links via HATEAOS wurden dabei als eigendes Property links[] definiert. 

Anschliessend wurde mittels Angular-http Client ein Get-Request an die entsprechende URL gesendet. Das resultierende Observable wurde abonniert und anschliessend mittels Angular Direktive als Card Element dargestellt. 

\begin{figure}[h]
		\centering
		\includegraphics[scale=0.3]{images/productsPhone.PNG}
		\caption[Produktanzeige auf Pixel Phone]{Produktanzeige auf Pixel Phone,\\ Quelle: Autor}
		\label{img: Prodcuts pixel}
\end{figure}

\begin{figure}[h]
		\centering
		\includegraphics[scale=0.3]{images/productsTablet.PNG}
		\caption[Produktanzeige auf iPad]{Produktanzeige auf iPad,\\ Quelle: Autor}
		\label{img: Products iPad}
\end{figure} 

Anschliessend wurde mittels CSS das Design wie gewünscht angepasst. 

\paragraph{Sprintreview Sprint 3}
Die Userstory von dieser Woche konnten erneut nicht abgeschlossen werden. Aus diesem Grund wird sie für den nächsten Sprint weiter verfeinert. Die resultierenden Stories sind dabei: 
\begin{itemize}
	\item Das System bietet die Möglichkeit, Produkte anzuzeigen
	\item Das System bietet die Möglichkeit, ein Produkt dem Warenkorb hinzuzufügen
\end{itemize}

Diese Userstories ersetzen die bestehende.


\subsubsection{Sprint 4}
\begin{table}[H]
	\begin{tabularx}{\textwidth}{|l|X|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System bietet die Möglichkeit, ein Produkt anzuzeigen& F.2\\
		\hline
		Das System bietet die Möglichkeit, ein Produkt dem Warenkorb hinzuzufügen& F.2\\
		\hline
	\end{tabularx} 
	\caption[Userstories Sprint 4]{Userstories Sprint 4,\\ Quelle: Autor}
\end{table}\label{userStoriesSprint4}

\subparagraph{Produkte anzuzeigen}
Vom Auftraggeber wurden die Produkte in einer Excel Liste abgegeben. Hierbei war auch ein Packshot vorhanden. Es wurde relativ schnell klar, dass dieser nur für die mobile Ansicht geeignet war, da die Auflösung sehr gering war. Auf Nachfrage wurden anschliessend hochauflösende Bilder zur Verfügung gestellt. Allerdings war hier die Qualität zu gut. Das Laden der Seite verzögerte sich merklich. Aus diesem Grund mussten die Bilder komprimiert und in der Auflösung angepasst werden. Zur Komprimierung wurde das Online Tool von https://compresspng.com/ genutzt. Die Auflösung wurde mit dem Preview Programm von MacOS angepasst. Dadurch konnte die Grösse eines Bildes von ca. 2MB auf 100KB heruntergebrochen werden. Die Bilder sehen dabei für den Betrachter immer noch scharf aus. Zudem konnten die Bilder so alle auf das selbe Format gebracht werden. \\
Um die Produkte hinzuzufügen, wurde Postman genutzt. Die einzelnen Produkte-JSONs wurden dabei einmal erstellt und könnten bequem via Runner hinzugefügt werden. 
Zusätzlich wurde eine Sortier-Funktion implementiert. Mittels dieser kann die Darstellungsreihenfolge angepasst werden. Es wurde hier die ngx Order-Pipe genutzt. \\
Bei einem Klick auf ein Produkt soll zudem die Detail View von diesem angezeigt werden. Dies war mittels Router Link sehr leicht umzusetzen. Mittels dem ProductService wird das ausgewählte Produkt gesetzt und auf der Detail View angezeigt. Das Design dieser Komponente wird auf später verschoben, da die Warenkorbfunktionalität wichtiger ist. 

\subparagraph{Produkte dem Warenkorb hinzufügen}
Für die Realisierung des Warenkorbes gestaltete sich als simpel. Angular liefert hierzu ein hauseigenes Tutorial. Dieses wurde erweiter, sodass CartItems gespeichert werden. Zusätzlich werden diese im Local Storage des Browser gespeichert, sodass der Warenkorb auch nach einem Reload noch vorhanden ist [\cite{cartAngular}].

Der Warenkorb wird als Angular Material List dargestellt. Die Artikelanzahl kann mittels Buttons angepasst werden. Ein Löschen wird durch einen zusätzlichen Button ermöglicht. Zusätzlich wird das Gesamttotal der im Warenkorb befindlichen Artikel bei jeder Änderung neu berechnet. 

\begin{figure}[h]
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/cartEmpty.PNG}
		\caption[Leerer Warenkorb]{Leerer Warenkorb,\\ Quelle: Autor}
		\label{img: cartEmpty}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.4\textwidth}
		\includegraphics[scale=0.4]{images/cartFull.PNG}
		\caption[Warenkorb mit Produkten]{Warenkorb mit Produkten,\\ Quelle: Autor}
		\label{img: cartFull}
	\end{subfigure}
\end{figure} 

\subparagraph{Https bei Backend}\label{httpsBackend}
Moderne Browser erlauben das Laden von sogenanntem Mixed-Content per Default nicht mehr. Mixed Content steht dabei für das Laden von Daten via http von einer https Seite. Um dieses Problem zu beheben, muss das Spring Boot Backend auch via https zugreifbar sein.  [\cite{mixedContent}]. Mit dem Tool Certbot kann ein gültiges Zertifikat erstellt werden. Dieses muss nun im application.propertie des Spring Projekts angegeben werden. Das Tutorial verwendete dabei eine deprecated Version von Certbot. Dank einem Hinweis von Ubuntu wurde auf die neue Version gewechselt [\cite{springSSL}]. 

\begin{verbatim}
	certbot certonly --webroot  -d bdaf21-owerlen.enterpriselab.ch 
	--staple-ocsp -m oliverwerlen@bluewin.ch --agree-tos
\end{verbatim}

Es wird empfohlen, in Spring mit PKCS12 Files zu arbeiten. Daher wurde das erstellte PEM File zu einem solchen konvertiert. \\\\
Certbot führt die Zertifikatserneuerung von selbst aus. Das jetzt verwendete Zertifikat ist 90 Tage gültig, es sollte daher bis zum Projektende keine Probleme bereiten. \\

\begin{verbatim}
	openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem -out 
	keystore.p12 -name jtipickupbackend -CAfile chain.pem -caname root
\end{verbatim}

\subparagraph{Sprintreview Sprint 4}
Im Sprint 4 konnte die Warenkorbfunktionalität abgeschlossen werden. Zudem läuft die Applikation nun auch im produktiven Umfeld.
Um die Bestellung abschliessen zu können, muss im nächsten Schritt die Authentifizierung implementiert werden.  

\subsubsection{Sprint 5}
\begin{table}[H]
	\begin{tabularx}{\textwidth}{|l|X|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System bietet dem Anwender die Möglichkeit, sich zu registrieren& F.2\\
		\hline
	\end{tabularx} 
	\caption[Userstories Sprint 5]{Userstories Sprint 5,\\ Quelle: Autor}
\end{table}\label{userStoriesSprint5}
 In vorherigen Sprints konnten die User Stories selten Fertiggestellt werden. Aus diesem Grund wurde hier nur eine kleine Story hinzugenommen.
 
\paragraph{Authentifizierung}
\subparagraph{Backend}
 In einem vorherigen Projekt wurde bereits eine Authentifizierung in Spring Boot umgesetzt. Das dort verwendete Tutorial funktionierte dabei tadellos. Aus diesem Grund wurde entschieden, bei diesem Projekt identisch vorzugehen. Nachfolgendes Sequenzdiagramm zeigt dabei auf, wie die einzelnen Teile miteinander kommunizieren. Dabei wurde auf eine Token Based Authentifizierung realisiert. Umgesetzt wurde sie mittels Spring Security. Der Token muss dabei bei jedem Request mitgesendet werden. [\cite{authAPISpring}]
  
\begin{figure}[H]
  	\centering
  	\includegraphics[width=1\textwidth]{images/Authentication.PNG}
  	\caption[Authentication im Backend]{Authentication im Backend,\\ Quelle: Autor}
  	\label{img: AuthenticationBackend}
\end{figure} 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/jwtIO.PNG}
	\caption[Token Auflösung mit jwt.io]{Token Auflösung mit jwt.io,\\ Quelle: Autor}
	\label{img: jwtio}
\end{figure} 

Es wurden zudem Rollen definiert, um die API feingranular sichern zu können. Die Rollen lauten dabei: 

\begin{itemize}
	\item User
	\item Admin
	\item Maintenance
\end{itemize}

Ein entsprechendes Rollenkonzept wird bei Bedarf erstellt und der Dokumentation angefügt. 

\subparagraph{Frontend}

Um einen ensprechenden Nutzer zu erstellen bzw. die Eingabe von Logininformationen zu ermöglichen, mussten die entsprechenden Formulare erstellt werden. Dies wurde dabei mittels Reactive Forms umgesetzt. Durch die damit verbundenen Validators wird Clientseitig auf die Komplexität des Passworts, das Übereinstimmen der beiden sowie die Korrektheit der Email Adresse getestet. 

\begin{figure}[H]]
 	\begin{subfigure}[b]{0.4\textwidth}
 		\includegraphics[scale=0.3]{images/loginForm.PNG}
 		\caption[Login Formular]{Login Formular,\\ Quelle: Autor}
 		\label{img: loginForm}
 	\end{subfigure}
 	\hfill
 	\begin{subfigure}[b]{0.4\textwidth}
 		\includegraphics[scale=0.3]{images/registerForm.PNG}
 		\caption[Registrierungsformular]{Registrierungsformular,\\ Quelle: Autor}
 		\label{img: registerForm}
 	\end{subfigure}
\end{figure} 
 
 Die Email-Adresse sowie der Nutzername wird Serverseitig auf die Einzigartigkeit überprüft. 
 
Wie oben erwähnt, muss bei jedem Request der passende Header mitgesendet werden. Um dies ohne grossen Aufwand durchführen zu können, wird analog zum Backend ein passendes Tutorial zum Frontend bereitgestellt. Angular bietet dabei die Möglichkeit, mit Auth-Interceptors zu arbeiten. Dieser fügt jedem API Call den entsprechenden Token im Header an. Der Interceptor dient als Proxy. [\cite{authAPIAngular}]

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/authInterceptor.PNG}
	\caption[Authentication Interceptor]{Authentication Interceptor,\\ Quelle: Autor}
	\label{img: authInterceptor}
\end{figure} 
  
Beim erfolgreichen Anmelden wird der Token im Session Storage gespeichert. Zudem wird der Nutzernamen mitgespeichert. 

\begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{images/sessionStorage.PNG}
 	\caption[Token im Session Storage]{Token im Session Storage,\\ Quelle: Autor}
 	\label{img: sessionStorage}
\end{figure} 
 
 Mittels Angular Direktiven wird das Menu für eingeloggte User angepasst. Es wird der Logout Button eingeblendet. Bei einem Klick auf diesen wird der Session Storage gelöscht. 
 
\subsubsection{Sprintreview Sprint 5}
 Im Sprint 5 konnte die geplante User Story erfolgreich abgeschlossen werden.
 
 
\subsubsection{Sprint 6}
\begin{table}[H]
	\begin{tabularx}{\textwidth}{|l|X|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System ermöglicht die Anbindung an einen bereits bekannten Bezahldienst, \\
		um eine sichere Bezahlung zu garantieren.& F.7\\
		\hline
	\end{tabularx} 
	\caption[Userstories Sprint 6]{Userstories Sprint 6,\\ Quelle: Autor}
\end{table}\label{userStoriesSprint6}
\paragraph{Bezahlungsanbieter}
In der Sitzung \ref{04.03.2021} wurde vom Auftraggeber bekannt gegeben, dass sie bei bereits bestehenden Lösungen den Bezahlvorgang mit dem Anbieter Six Payment Services durchführen. 

\paragraph{Einführung}
Six Payment bietet einen Integration Guide an, um die Integration in den eigenen Online Store zu erleichert. [\cite{sixECommerce}] Dabei wird eine JSON API zur Verfügung gestellt, um die Bezahlung durchzuführen. 
\subparagraph{Anforderungen}
Das Vorgehen wurde identisch zum empfohlenen Vorgehen auf der Developer Seite durchgeführt. Dabei wurde zur Consultation die API-Dokumentation durchgelesen. Nachfolgend werden die wichtigsten Requirements aufgeführt. 
\begin{itemize}
	\item JSON API Basic Authentication
	\item TLS 
	\item mindestens ein aktiver Terminal
	\item Terminal Nummer und Customer Nummer
	\item gütliges "acceptance agreement" für Kreditkarten
\end{itemize} 
[\cite{jsonAPISix}]
\subparagraph{Data Security}
Um falsche Anwendungen und missbrauch von Kreditkarten zu verhindern, wurde von den Kreditkartenorganisationen das Sicherheitsprogramm \ac{PCI DSS} ins Leben gerufen. \\
Dieser Standard kann dabei erfüllt werden, wenn die Bezahlung auf dem Saferpay Formular durchgeführt wird. Dieses Formular wird direkt beim Anbieter gehostet. Es werden keine Bezahlungsdaten auf dem eigenen Web Server verarbeitet, gesendet oder gespeichert. Somit ist es auch weniger Aufwendig, die PCI DSS merchant certification zu erhalten. [\cite{jsonAPISix}]

\subparagraph{Certification Levels}
Die \ac{PCI DSS} Zertifikation ist in verschiedene compliance Level aufgeteilt. Die beiden Wichtigsten sind dabei \ac{SAQ}-A und \ac{SAQ}-A EP. Nachfolgend wird nur \ac{SAQ}-A näher angeschaut. \\\\
Bei \ac{SAQ}-A wird die Verantwortung vollständig an den Bezahlanbieter abgegeben. Saferpay stellt dabei die Möglichkeit zur Verfügung, die erforderlichen Bedingungen zu erfüllen. Die Bedingungen lauten dabei: 
\begin{itemize}
	\item Nutzen von eigenem HTML Formular Verboten
	\item Jedes Feld auf der Payment Page muss von einem PCI Zertifizierten Anbieter gehosted werden
	\item Änderungen an der Bezahlseite via CSS oder JavaScript sind Verboten
\end{itemize}

\subparagraph{Testsystem vs. Live System}
Saferpay stellt zum Testing einen Testaccount zur Verfügung. Die wesentlichen Unterschiede sind dabei:
\begin{itemize}
	\item Testsystem und Livesystem sind nicht miteinander verbunden
	\item Beim Testsystem werden richtige Kreditkarten nicht akzeptiert
	\item Kein Geld wird beim Testsystem transferiert
	\item Systemverhalten bleibt identisch
	\item URLs sehr ähnlich 
\end{itemize}

\paragraph{Auf Livesystem wechseln}
Um von einem Testsystem auf ein Livesystem zu wechseln, sind einige kleine Änderungen vorzunehmen. 
\begin{itemize}
	\item Authorization Token anpassen
	\item Anpassen von IDs
	\item Anpassen der Request URL
\end{itemize} 

\subparagraph{Allgemeine Informationen}
In diesem Projekt wird nur mit dem Testsystem gearbeitet. Ein Wechsel auf ein Livesystem ist nicht geplant. 
 
 \paragraph{Integration in Web Applikation}
 In einem ersten Schritt wurde ein Testsystem beim Anbieter angefragt.
 Um mit der JSON API kommunizieren zu können, sind im Header des Requests einige Parameter mitgegeben werden. Der korrekte Header sieht folgendermassen aus: 
 \begin{verbatim}
	"Content-Type": "application/json", 
	"Authorization": "Basic QVBJXzI1Nzc1M183NTU3MTMyMjpKc29uQXBpUHdkMV9SalVEQzJzaw==",
 \end{verbatim}
Der Token wird dabei im Testsystem generiert. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/basicAuth.PNG}
	\caption[Erstellen des Basic Authentication Token im Back Office]{Erstellen des Basic Authentication Token im Back Office,\\ Quelle: Autor}
	\label{img: basicAuth}
\end{figure} 
 \subparagraph{Payment Initialization Page}
 An die API muss der entsprechende Request gesendet werden, um den Bezahlvorgang zu starten. Dazu muss der passende Request an die folgende URL gesendet werden: 
 \begin{verbatim}
 	https://test.saferpay.com/api/Payment/v1/PaymentPage/Initialize
 \end{verbatim}
In der API-Dokumentation ist dabei ein Demo Request zu finden. Die Parameter lassen sich aus dem Backend herauslesen. 
Der Body der Anfrage ist in \ref{img: requestNew} zu finden. 
Dabei wurde bewusst auf das Erstellen eines entsprechenden TypeScript Interfaces verzichtet. 
Dies musste jedoch bei der Antwort vorgenommen werden. 
Es wurde dazu ein Interface passend zur Antwort erstellt. Anschliessend wird die Antwort zum Typen umgewandelt. 

Die Anfrage an den Server geschieht dabei asynchron. Somit ist nicht voraussehbar, wann der Request ausgeführt wird, bzw. wann die Antwort gesetzt wird. Jedoch muss in diesem Anwendungsfall auf die URL im Body weitergeleitet werden. Um auf die Antwort zu warten, wurde das selbe Vorgehen wie in \ref{img: observableState} verwendet. 
Wie bereits beschrieben, wird der User auf die Zahlungsseite von Saferpay weitergeleitet. Nach dem Abschluss der Bezahlung wird entweder auf die Success-URL oder die "Fail-URL" von obigem Request umgeleitet. 
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/paymentSaferpay.PNG}
	\caption[Saferpay Bezahlseite]{Saferpay Bezahlseite,\\ Quelle: Autor}
	\label{img: paymentSaferpay}
\end{figure} 

\subparagraph{Payment Assert}
Das Vorgehen zur Bezahlverifikation ist dabei idenitisch zur Zahlungsauslösung. 
\begin{verbatim}
	https://test.saferpay.com/api/Payment/v1/PaymentPage/Assert
\end{verbatim}
Um die Bezahlung identifizieren zu können, muss der Token aus vorheriger Antwort mitgegeben werden. Dieser wird im Session Storage gespeichert. 
Der genaue Request sieht folgendermassen aus: 
\begin{verbatim}
	  let request = {
		"RequestHeader": {
			"SpecVersion": 1.21,
			"CustomerId": this.customerId,
			"RequestId": this.requestId,
			"RetryIndicator": 0
		},
		"Token": this.getToken()
	}
\end{verbatim}
Um das Interface für die Antwort zu definieren, wurde quicktype genutzt. Damit konnte aus dem Demorequest in der Dokumentation das passende Interface generiert werden. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/quickType.PNG}
	\caption[PagePaymentAssertResponse]{PagePaymentAssertResponse,\\ Quelle: Autor}
	\label{img: PagePaymentAssertResponse}
\end{figure} 

Es wird von diesem Request das Status Property gecheckt. Bei AUTHORIZED wird die Bezahlung als Erfolgreich markiert. Die Transaction-ID wird bei der Bestellung hinterlegt. Damit ist ein Mapping zwischen Bestellung und Bezahlung möglich. Die Bezahlung ist auch im Backend aufgelistet. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/paymentsBackoffice.PNG}
	\caption[Bezahlhistorie Backoffice]{Bezahlhistorie Backoffice,\\ Quelle: Autor}
	\label{img: paymentsBackoffice}
\end{figure} 

Der Bezahlprozess ist somit abgeschlossen. 

\paragraph{Ablauf}
Der Bezahlvorgang wird nachfolgend als Sequenzdiagramm dargestellt. Aus Einfachheitsgründen wurde auf die Darstellung des Proxies verzichtet. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/paymentSequence.PNG}
	\caption[Sequenzdiagramm vom Bezahlvorgang]{Sequenzdiagramm vom Bezahlvorgang,\\ Quelle: Autor}
	\label{img: paymentSequence}
\end{figure} 

\paragraph{CORS}\label{CORS}
"Cross-Origin Resource Sharing (CORS) ist ein Mechanismus, der zusätzliche HTTP Header verwendet um einem Browser mitzuteilen, dass er einer Webanwendung, die auf einer anderen Domain(Origin) läuft, die Berechtigung erteilt auf ausgewählte Ressourcen von einem Server eines anderen Ursprungs(Origin) zuzugreifen. Eine Webanwendung stellt eine cross-origin HTTP-Anfage, wenn sie eine Ressource anfordert, die einen anderen Ursprung(Domain, Protokoll und Port) hat, als ihren eigenen."[\cite{cors}]

Dies wurde auch bei diesem Projekt bemerkt. Die Requests an die API von Six wurden immer von \ac{CORS} geblockt. 

\subparagraph{Setzen von Access Header}
Wenn man Zugriff auf den betroffenen Server hat, so kann hier mittels entsprechenden CORS Headern gearbeitet werden. Dies wurde beispielsweise bei dem eigenen Backend umgesetzt. Da es sich um eine externe API handelt und dementsprechend kein Zugriff auf die Maschine besteht, ist dies keine mögliche Lösung. 

\subparagraph{Angular Proxy}
Angular bietet einen eigenen, integrierten Proxy um \ac{CORS} zu umgehen. Dabei werden Request mit einer bestimmten Addresse abgefangen und an den passenden Server umgeleitet.\\
In diesem Anwendungsfall funktionierte der Angular Proxy nicht wunschgemäss. Zudem eignet sich dieser nur im Entwicklungseinsatz. 

\subparagraph{Zusätzlicher Proxy auf localhost}\label{corsLocalhost}
Es wurde daher ein zusätzlicher Proxy umgesetzt. Dabei wurde ein NodeJS-Server mit express genutzt. Dieser besitzt keine Logik. Er nimmt lediglich Requests an und leitet diese an die Adresse im Header weiter. [\cite{corsProxy}] Die Requests werden nun via Proxy an die API gesendet. Zudem wird nun auch mit der eigenen API über diesen Proxy kommuniziert. Dies löst einerseits die \ac{CORS}-Problematik mit externen APIs und macht den Einsatz von HTTPS im Backend \ref{httpsBackend} überflüssig. Die \ac{TLS} wurde hier nur aufgrund der Browser Policies gebraucht. Der Proxy ist nun via localhost erreichbar. Hierbei ist die "Mixed Content" Policy nicht aktiv. Bei der Entwicklung bleibt das Backend direkt auch erreichbar. Im produktiven Betrieb würden nur noch Anfragen vom Proxy akzeptiert. \\
Zudem ist die Verschlüsselung der Kommunikation zwischen Backend und Frontend überflüssig, da sie nur auf der eigenen Maschine abläuft. Es werden keine Daten über eine unsichere Leitung gesendet. \\
Die Verbindung zur externen API läuft dabei via HTTPS. Dies wird von Six umgesetzt.\\\\
Um eine konstante \ac{CI/CD} zu ermöglichen, wurde dies für den Proxy umgesetzt. 
Angedacht war dabei, dass der Proxy auch im produktiven Umfeld via loopback-Adresse erreichbar ist. Dies bietet den Vorteil, dass die Browser diesem trauen und nicht via https zugreifbar gemacht werden muss. Der Traffic bleibt nur lokal auf der Maschine, daher bestehen keine Sicherheitsrisiken. Auf Google Chrome sowie auch Firefox funktionierte dies auch. Auf Safari ist die Loopback Adresse nicht vertrauenswürdig, der Proxy müsste via https erreichbar sein. Das Problem ist, dass Letsencrypt keine Zertifikate für localhost ausstellt [\cite{letsencryptLocalhost}].\\
Es besteht keine Möglichkeit, dieses Problem unter Safari zu beheben. Daher musste dieser Lösungsansatz verworfen werden. Das Problem wird auf den nächsten Sprint verschoben. 

\subparagraph{Backend als Proxy}
Dieses Vorgehen wird in Sprint 8 \ref{sprint8} genauer beschrieben. 
\paragraph{Problem mit Enterpriselab Host}
Am Mittwoch, 14.04. am Nachmittag war der GitLab Host nicht mehr erreichbar. Die Nachfrage beim Enterpriselab Team ergab, dass die Maschine ihre IP-Adresse verloren hatte. Ein Neustart brachte auch keinen Erfolg, da verschiedene wichtige Dienste nicht mehr starteten. Es wurde eine neue Maschine bereitsgestellt. Der Grund konnte nicht herausgefunden werden. \\\\
Die Umgebung konnte sehr schnell wieder hergestellt werden. Es musste nur Docker und Gitlab-Runner installiert und registriert werden. Zudem mussten die Daten neu migriert werden. Der Umfang der gesamten Neuumsetzung lag bei ca. 3h. 

\paragraph{Backend Models}
Die Bestellungen sollen im Backend persistiert werden. Bei der Erstellung der Order-Entity fiel dabei auf, dass diese diverse Beziehungen zu anderen Klassen hat. Dadurch wurde entschieden, dass diese auch implementiert werden. 
Dabei wurde strikt darauf geachtet, dass die gesamte API dem REST-Level 3 entspricht. Durch den Einsatz von Model Mapper wurde das Mapping von DTO und Datenbankobjekt vereinfacht. 


\subsubsection{Meilenstein Abschluss Bestellprozess und Zwischenpräsentation}
Nachfolgend werden die Meilensteinberichte zu den Meilensteinen 3 und 4 zusammen aufgeführt. 
 \paragraph{Meilensteinbericht}
 \subparagraph{Termin Meilenstein 3}
 Der Meilenstein 3 ist am 19.04.2021 abgeschlossen und somit pünktlich fertiggestellt worden.
 Der Meilenstein 4 ist am 21.04.2021 abgeschlossen und somit pünktlich fertiggestellt worden. 
 \subparagraph{Beschreibung Meilenstein 3}
 Die Beschreibung des Meilensteins ist im Abschnitt \ref{Meilensteine} ersichtlich. 
 \subparagraph{Meilensteinziele/Vorgaben}
Das übergeordnete Ziel dieses Meilensteins ist die der Abschluss des Bestellprozesses. 
 \begin{itemize}
 	\item Testprotokolle
 	\item Demo
 	\item Release 
 	\item Zwischenpräsentation
 \end{itemize}
Die Zwischenpräsentation ist im Anhang \ref{zwischenpraesentation} zu finden. 
Die Testprotokolle sind im Anhang \ref{testprotokolleBestellung} zu finden. 
 \subparagraph{Meilensteinzielerreichung}
Die Meilensteine konnten grösstenteils erfüllt werden. Einzig die Altersverifikation mittels Jumio wurde nach hinten verschoben. Die hing jedoch mit Abhängigkeiten zum Auftraggeber zusammen. Jedoch ist das Backend bereits sehr weit fortgeschritten.  
Die Zwischenpräsentation wurde erfolgreich durchgeführt. 
 \subparagraph{Fazit}
Es konnten viele der geplanten Artefakte abgeliefert werden. Die fehlende Integration von Jumio wurde durch den Fortschritt im Backend kompensiert. Zudem funktioniert die Bezahlung aufgrund von CORS-Problemen nicht auf allen modernen Browsern. Hier muss in den kommenden Sprints nachgebessert werden. 

\subsection{Realisierungsphase}
\subsubsection{Sprint 7}
\begin{table}[H]
	\begin{tabularx}{\textwidth}{|l|X|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System bietet dem Kunden die Möglichkeit, alle vorhandenen Pick-Up \\Stations anzuzeigen. & F.8\\
		\hline
		Das System bietet dem Kunden die Möglichkeit, die für Ihn nächstgelegene\\ Station auswählen zu können. & F.7\\
		\hline
	\end{tabularx} 
	\caption[Userstories Sprint 7]{Userstories Sprint 7,\\ Quelle: Autor}
\end{table}\label{userStoriesSprint7}
\paragraph{Anzeigen von Pick-Up Stations}
\subparagraph{Google Maps}
Google Maps gilt als der Standard bei digitalen Karten. Seit einigen Jahren verfolgt Google jedoch ein sehr undurchsichtiges Bezahlmodell. Dem Kunden werden 200 Dollar Kredit pro Monat kostenlos zur Verfügung gestellt. Eine weitere Nutzung würde in diesem Anwendungsfall mit 2 Dollar je 1000 Anfragen belastet. \\
Für den Entscheid gegen Google Maps ausschlaggebend war der Zwang, eine Kreditkarte zu hinterlegen. 
\subparagraph{Geoapify}
Als Alternative zu Google Maps wird Geoapify angeboten. Es bietet sehr ähnliche Funktionen, jedoch ohne Zwang, eine Kreditkarte zu hinterlegen. Bei Geoapify sind 3000 Requests pro Tag kostenlos. 
\subparagraph{Leaflet}
Leaflet ist eine Open Source native Java Script Library für benutzerfreundliche, interaktive mobile Maps. [\cite{leaflet}]
\subparagraph{OpenLayers}
Open Layers dient als Alternative zu Leaflet. Dabei ist OpenLayers für komplexere Applikationen ausgelegt. [\cite{leafletVsOpenlayers}]
Für dieses Projekt wird jedoch nur ein begrenzter Umfang gebraucht, daher wird mit Leaflet gearbeitet. 

\subparagraph{Open Street Map}
Als Karte wird dabei Open Street Map genutzt. Open Street Map untersteht dabei einer freien Lizenz. Die Daten werden dabei hauptsächlich von der Community gepflegt. Die Nutzung bleibt dabei kostenlos. Die Open Street Map Contributors müssen auf der Applikation ersichtlich sein.  [\cite{openStreetMap}]
\subparagraph{Anzeigen einer Map mit Leaflet}
Geoapify stellt hierzu einige Tutorials zur Verfügung, um den Einstieg zu vereinfachen. Dabei wird eine einfache Karte erstellt. [\cite{geoapifyLeaflet}]


\subparagraph{Marker und Popup Funktionalität}
Die einzelnen Marker werden aus den Daten vom Backend erstellt. Diese werden via Request vom Backend geladen und angezeigt. Zudem werden die entsprechenden Inventories zu jeder Station geladen. Da hier mit HATEOAS gearbeitet wurde, mussten die Produkte separat geladen werden. \\
Die Produktverfügbarkeit an einer Station sollte dabei als Popup dargestellt werden. Um dies für den Nutzer übersichtlich zu gestalten, wird die Verfügbarkeit gefärbte Kreise dargestellt. 
Beim Anzeigen der Popups ergab sich jedoch die Problematik, dass dies auf Geräten aus dem Hause Apple nicht funktionierte. Dabei wurde der Event von Leaflet nicht korrekt erkannt. Nach einigen Recherchen konnte keine Lösung gefunden werden. Ähnliche Fälle sind dabei nicht bekannt. \\
In der Dokumentation von Leaflet ist jedoch eine Alternative zu den Popups zu finden. Diese Tooltips werden dabei zum Anzeigen von kleinen Texten auf der Karte genutzt. Für die geplante Funktion sind diese somit geeignet. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/tooltipImp.PNG}
	\caption[Erstellung von Marker und Tooltip]{Erstellung von Marker und Tooltip,\\ Quelle: Autor}
	\label{img: tooltip}
\end{figure} 

 \begin{figure}[H]
 	\centering
 	\includegraphics[scale=0.5]{images/tooltipCard.PNG}
 	\caption[Darstellung von Marker und Tooltip]{Darstellung von Marker und Tooltip,\\ Quelle: Autor}
 	\label{img: tooltipCard}
 \end{figure} 
 
 Ein Problem war dabei, dass die Get-Requests von RxJS asynchron ausgeführt werden. Dies bietet einerseits den Vorteil, dass die Applikation während dem Laden von Daten nutzbar bleibt, andererseits ist in diesem Fall essentiell, dass einige Prozesse aufeinander warten. Das Vorgehen wird dabei nachfolgend kurz chronologisch dargestellt: 
 \begin{enumerate}
 	\item Laden von aktueller Location des Benutzers
 	\item Erstellen der Map inkl. Kontrollelemente
 	\item Laden der PickUp-Stations vom Server
 	\item Laden des Inventars vom Server pro PickUp
 	\item Laden von einzelnen Produkten von Inventar
 	\item Hinzufügen von Marker auf Map 
\end{enumerate}
Wie hier zu sehen, sind die Daten von einander Abhängig. So kann das Inventar nicht geladen werden, ohne dass die PickUp Station vorhanden ist und so weiter. Es muss immer auf das Resultat gewartet werden. Um genau dies zu ermöglichen, triggered RxJS den State des Observables. Dabei gibt es drei wesentliche Zustände: next, completed und error. 

 \begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/observable.PNG}
	\caption[Observable States]{Observable State,\\ Quelle: Autor}
	\label{img: observableState}
\end{figure} 

Next liefert dabei einen Wert, Error einen JavaScript Error oder eine Exception und completed nichts zurück. 
Error wird bei den hier genutzten Abfragen immer direkt mittels pipe abgefangen. \\
Mit diesem Vorgehen kann auf das vorhergehende Resultat gewartet werden. Dies wird sehr viel genutzt. 

\subsubsection{Auswahl der PickUp Station}
In Abbildung \ref{img: observableState} ist zu sehen, dass beim Öffnen des Tooltips ein click-Event abgefangen wird. Dabei wird ein Leaflet Event mitgegeben, welcher unter anderem auch die Koordinaten der geklickten Station enthält. Basierend auf diesen Daten wird die ausgewählte PickUp Station gesetzt. Diese wird im Local Storage des Browsers gespeichert. 
 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/mouseEvent.PNG}
	\caption[Mouse Event]{Mouse Event,\\ Quelle: Autor}
	\label{img: MouseEvent}
\end{figure} 
\subsubsection{Sprintreview Sprint 7}
Die User Story konnte erfolgreich durchgeführt werden. 

\subsubsection{Sprint 8}\label{sprint8}
\begin{table}[H]
	\begin{tabularx}{\textwidth}{|l|X|}
		\hline
		\textbf{User Story} & \textbf{Number} \\
		\hline
		Das System ermöglicht die Anbindung an einen bereits bekannten Bezahldienst,\\ um eine sichere Bezahlung zu garantieren.  & F.6\\
		\hline
		Das System bietet dem Kunden die Möglichkeit, verschiedene Produkte zu bestellen& F.7\\
		\hline
	\end{tabularx} 
	\caption[Userstories Sprint 8]{Userstories Sprint 8,\\ Quelle: Autor}
\end{table}\label{userStoriesSprint8}
Bemerkungen: In Sprint 2  \ref{sprint2} und Sprint 3 wurde bereits die gleiche Userstory bearbeitet. In diesem Sprint wird dabei die Persistierung der Bestellung auf dem Backend durchgeführt. Zudem wird das CORS-Problem \ref{CORS} bei der Bezahlung neu angegangen. 

\paragraph{Persistierung der Bestellung}
In einem vorhergehenden Sprint wurden die entsprechenden Methoden und Entitäten für die Erstellung von Orders bereits erstellt. Nachfolgendes Entity Relationship Diagramm liefert einen Überblick. 
 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{images/erdOrder.PNG}
	\caption[Entity Relationship Diagram von Order]{Entity Relationship Diagram von Order,\\ Quelle: Autor}
	\label{img: erdOrder}
\end{figure} 
Hierbei ist zu sehen, dass die Erstellung einer Order drei Eigenschaften benötigt: 
\begin{itemize}
	\item User
	\item PickUpStation
	\item OrderItem
\end{itemize}
Dabei wird auch hier mit DTOs gearbeitet. Das Vorgehen ist in \ref{DTO} beschrieben. \\
Die Order wird Erstellt, sobald der Benutzer auf den Checkout-Button im Warenkorb klickt. Es wird dabei überprüft, ob eine PickUp-Station ausgewählt wurde und der Warenkorb nicht leer ist. Nach dem erfolgreichen Hinzufügen der Order \ref{img: createOrder} werden die Order-Items erstellt. Hierzu wird pro Item im Warenkorb ein POST-Request durchgeführt \ref{img: createOrderItems}. 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/createOrder.PNG}
	\caption[Erstellen der Order]{Erstellen der Order,\\ Quelle: Autor}
	\label{img: createOrder}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/createOrderItems.PNG}
	\caption[Erstellen der OrderItems]{Erstellen der OrderItems,\\ Quelle: Autor}
	\label{img: createOrderItems}
\end{figure}

Der Benutzer wird dabei aus dem Authentifizierungstoken im Backend ausgelesen. 
Nach dem diese Abfragen completed sind, wird der Bezahlvorgang ausgelöst. 

\paragraph{Behebung des CORS-Problems}
Um CORS zu umgehen, wurde ein eigener NodeJS-Proxy implementiert und auf die virtuelle Maschine im GitLab deployed. Wie bereits in \ref{corsLocalhost} beschrieben, funktioniert dies unter Safari nicht. Der Ansatz mit einem eigenden Proxy wurde verworfen. Dies hing damit zusammen, dass der Reverse-Proxy \ref{reverseProxy} die Anfragen an den Proxy nicht korrekt weiterleitete. Das Problem konnte nicht identifiziert werden. \\ Es wurde nach einem neuen Ansatz gesucht, wobei die Wahl auf die Nutzung des eigenen Backends als Proxy fiel. Dabei übernimmt das Backend noch weitere Aufgaben bei der Bezahlung. So wird der finale Request erst im Backend erstellt. Vom Frontend kommt ein leeres Payment Initialize Objekt. In diesem sind nur die Order-Id sowie die redirect-URLs gesetzt. Es wird im Backend aus dem gesendeten leeren JSON ein entsprechendens Objekt erstellt und die fehlenden Daten gesetzt. Das Erstellen der Klasse wurde dabei analog zu \ref{img: PagePaymentAssertResponse} mittels quicktype durchgeführt. Allerdings sind die einzelnen JSON-Properties bei der Saferpay API grossgeschrieben, was nicht mit der Java-Namenskonvention übereinstimmt. Es handelt sich hierbei jedoch nur um DTOs, daher wurde dies hier vernachlässigt. 
\begin{figure}[H]
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[scale=0.5]{images/paymentOld.PNG}
		\caption[Payment Initialization alt]{Payment Initialization alt,\\ Quelle: Autor}
		\label{img: requestOld}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.5\textwidth}
		\includegraphics[scale=0.5]{images/paymentNew.PNG}
		\caption[Payment Initialization neu]{Payment Initialization neu,\\ Quelle: Autor}
		\label{img: requestNew}
	\end{subfigure}
\end{figure} 
Ausschlaggebend bei diesem Request ist die Order-Id. Diese wird bei der Persistierung der Order gespeichert und anschliessend im Frontend im Local Storage gespeichert. Sie wird auch als Request-Id genutzt. Diese ist im gesamten System einzigartig. Die Bezahlung kann im Backoffice über diese Id eindeutig identifiziert werden. \\
\subparagraph{Setzen der fehlenden Properties}
Wie in der Abbildung \ref{img: requestNew} zu sehen ist, beinhaltet der Request nur die Order-Id. Die restlichen Daten werden im Backend gesetzt. Dabei werden die Werte aus dem Properties-File gelesen und zur Laufzeit den Variablen zugewiesen. 

 \begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{images/valuesFromProperties.PNG}
	\caption[Auslesen der Werte aus .properties-File]{Auslesen der Werte aus .properties-File,\\ Quelle: Autor}
	\label{img: valuesFromProperties}
\end{figure} 
Der Bestellwert wird ebenfalls im Backend gesetzt. Dies macht es unmöglich, dem Bestellwert im Frontend anzupassen und so eine Vergünstigung zu erhalten. Um den Wert zu bestimmen, werden alle OrderItems die zur Order gehören in der Datenbank gesucht und der Produktpreis mit der Anzahl Produkte summiert. Dank streams in Java kann dies sehr elegant durchgeführt werden. Java empfiehlt den Gebrauch von Atomic Datentypen, wenn diese mit Streams bearbeitet werden. 
 \begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/calculateTotal.PNG}
	\caption[Berechnung des Order-Totals]{Berechnung des Order-Totals,\\ Quelle: Autor}
	\label{img: orderTotal}
\end{figure} 
Zudem schreibt die API von Sixpayment vor, dass der Wert ohne Kommastellen angegeben wird. Dies wird hier durch die Multiplikation mit dem Faktor 100 erreicht.
Durch das DecimalFormat werden die Nachkommastellen entfernt. 

\subparagraph{Senden eines POST-Requests von Spring}
Um einen POST-Request von Spring an eine andere API zu senden, wurde RestTemplate genutzt. [\cite{restTemplate}] Dazu wurde eine HttpEntity mit dem gewünschten Body und dem passenden Header erstellt. Das Erstellen dieser wurde in einen Service \ref{img: httpEntity} ausgelagert. 
\begin{figure}[H]
	\includegraphics[width=1\textwidth]{images/restTemplate.PNG}
	\caption[Senden eines Request mit Rest Template]{Senden eines Request mit Rest Template,\\ Quelle: Autor}
	\label{img: restTemplate}
\end{figure}
\begin{figure}[H]
	\includegraphics[width=1\textwidth]{images/httpEntity.PNG}
	\caption[Erstellen der HttpEntity]{Erstellen der HttpEntity,\\ Quelle: Autor}
	\label{img: httpEntity}
\end{figure}

Die Antwort von diesem Request wird vom Backend direkt weitergeleitet. \\Im Frontend wird der Token im Local Storage gespeichert. Dieser wird beim Payement Assert gebraucht.
\\
Im nächsten Schritt wird das PaymentAssert durchgeführt. Wie auch bereits in obigen Beispiel gesehen, werden auch hier die meisten Daten im Backend gesetzt. Hier wird der Token sowie die Request-Id aus dem Local Storage mitgegeben. \\
Als Antwort auf diesen Request wird der Statuscode zurückgegeben. Zudem wird die Order in der Datenbank als Bezahlt markiert. 
 \begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{images/pageAssertReturn.PNG}
	\caption[Überprüfung des Zahlungsstatus]{Überprüfung des Zahlungsstatus,\\ Quelle: Autor}
	\label{img: pageAssertReturn}
\end{figure} 
Dieser wird im Frontend überprüft, eine entsprechende Meldung ausgegeben und ein Redirect auf das Nutzerprofil durchgeführt. Der Bezahlvorgang ist abgeschlossen. 
\newpage
